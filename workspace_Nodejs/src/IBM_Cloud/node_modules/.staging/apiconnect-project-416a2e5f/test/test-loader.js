/********************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2017
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/
// Node module: apiconnect-project
'use strict';

var _ = require('lodash');
var f = require('util').format;
var fs = require('fs');
var loader = require('..');
var path = require('path');
var test = require('tap').test;
var yaml = require('js-yaml');

var maa = path.resolve(__dirname, path.join('fixtures', 'lbapp2', 'definitions', 'my-api-api.yaml'));
var maaraw = fs.readFileSync(maa).toString();
var maaparsed = yaml.safeLoad(maaraw);
var maamtime = fs.statSync(maa).mtime;

var ma = path.resolve(__dirname, path.join('fixtures', 'lbapp2', 'definitions', 'my-api.yaml'));
var maraw = fs.readFileSync(ma).toString();
var maparsed = yaml.safeLoad(maraw);
var mamtime = fs.statSync(ma).mtime;

var oa = path.resolve(__dirname, path.join('fixtures', 'lbapp2', 'definitions', 'other-api.yaml'));
var oaraw = fs.readFileSync(oa).toString();
var oaparsed = yaml.safeLoad(oaraw);
var oamtime = fs.statSync(oa).mtime;

var ssgarel = path.join('fixtures', 'swiftserverapp', 'definitions', 'swiftserverapp.yaml');
var ssga = path.resolve(__dirname, ssgarel);
var ssgaraw = fs.readFileSync(ssga).toString();
var ssgaparsed = yaml.safeLoad(ssgaraw);
var ssgamtime = fs.statSync(ssga).mtime;

var ssgprel = path.join('fixtures', 'swiftserverapp', 'definitions', 'swiftserverapp-product.yaml');
var ssgp = path.resolve(__dirname, ssgprel);
var ssgpraw = fs.readFileSync(ssgp).toString();
var ssgpparsed = yaml.safeLoad(ssgpraw);
var ssgpmtime = fs.statSync(ssgp).mtime;

test('loadProject loads artifacts in LB project', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'lbapp2')))
    .then(function(details) {
      t.deepEqual(details, [ {
        type: 'swagger',
        filePath: maa,
        name: 'my-api',
        version: '1.0.0',
        raw: maaraw,
        mtime: maamtime,
        data: maaparsed,
      }, {
        type: 'product',
        filePath: ma,
        raw: maraw,
        mtime: mamtime,
        data: maparsed,
        name: 'my-api-product',
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: maa,
          raw: maaraw,
          mtime: maamtime,
          data: maaparsed,
          name: 'my-api',
          version: '1.0.0',
        } ],
      }, {
        type: 'product',
        filePath: oa,
        raw: oaraw,
        mtime: oamtime,
        data: oaparsed,
        name: 'my-api-product',
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: maa,
          raw: maaraw,
          mtime: maamtime,
          data: maaparsed,
          name: 'my-api',
          version: '1.0.0',
        } ],
      } ]);
      t.end();
    });
});

test('loadProject loads artifacts in LB project without api info', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'lbapp-noinfo')))
    .then(function(details) {
      t.equal(details[0].type, 'swagger');
      t.equal(details[0].err, undefined);
      t.end();
    });
});

test('loadProject loads artifacts in LB project dir', function(t) {
  var dir = path.resolve(__dirname, path.join('fixtures', 'lbapp2', 'dir1', 'dir2'));
  loader.loadProject(dir)
    .then(function(details) {
      t.deepEqual(details, [ {
        type: 'swagger',
        filePath: maa,
        mtime: maamtime,
        name: 'my-api',
        version: '1.0.0',
        raw: maaraw,
        data: maaparsed,
      }, {
        type: 'product',
        filePath: ma,
        raw: maraw,
        mtime: mamtime,
        data: maparsed,
        name: 'my-api-product',
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: maa,
          mtime: maamtime,
          raw: maaraw,
          data: maaparsed,
          name: 'my-api',
          version: '1.0.0',
        } ],
      }, {
        type: 'product',
        filePath: oa,
        raw: oaraw,
        mtime: oamtime,
        data: oaparsed,
        name: 'my-api-product',
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: maa,
          raw: maaraw,
          mtime: maamtime,
          data: maaparsed,
          name: 'my-api',
          version: '1.0.0',
        } ],
      } ]);
      t.end();
    });
});

test('loadProject globs all artifacts in LB project', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'lbapp', 'dir1', 'dir2')))
    .then(function(details) {
      var maa = path.resolve(__dirname, path.join('fixtures', 'lbapp', 'definitions', 'my-api-api.yaml'));
      var maaraw = fs.readFileSync(maa).toString();
      var maaparsed = yaml.safeLoad(maaraw);
      var maaArtifact = {
        filePath: maa,
        name: 'my-api',
        type: 'swagger',
        version: '1.0.0',
        raw: maaraw,
        mtime: fs.statSync(maa).mtime,
        data: maaparsed,
      };

      var ma = path.resolve(__dirname, path.join('fixtures', 'lbapp', 'definitions', 'my-api.yaml')); // product
      var maraw = fs.readFileSync(ma).toString();
      var maparsed = yaml.safeLoad(maraw);
      var maArtifact = {
        filePath: ma,
        name: 'my-api-product',
        refs: [ maaArtifact ],
        type: 'product',
        version: '1.0.0',
        raw: maraw,
        mtime: fs.statSync(ma).mtime,
        data: maparsed,
      };

      var oa = path.resolve(__dirname, path.join('fixtures', 'lbapp', 'dir1', 'dir2', 'other-api.yaml'));
      var oaraw = fs.readFileSync(oa).toString();
      var oaparsed = yaml.safeLoad(oaraw);
      var oaArtifact = {
        filePath: oa,
        name: 'my-api-product',
        refs: [ maaArtifact ],
        type: 'product',
        version: '1.0.0',
        raw: oaraw,
        mtime: fs.statSync(oa).mtime,
        data: oaparsed,
      };

      t.deepEqual(details, [ maaArtifact, maArtifact, oaArtifact ]);
      t.end();
    });
});

test('loadProject globs artifacts with .apicignore file in LB project', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'lbapp3', 'dir1', 'dir2')))
    .then(function(details) {
      var maa = path.resolve(__dirname, path.join('fixtures', 'lbapp3', 'definitions', 'my-api-api.yaml'));
      var maaraw = fs.readFileSync(maa).toString();
      var maaparsed = yaml.safeLoad(maaraw);
      var maaArtifact = {
        filePath: maa,
        raw: maaraw,
        mtime: fs.statSync(maa).mtime,
        data: maaparsed,
        name: 'my-api',
        type: 'swagger',
        version: '1.0.0',
      };
      // .apiignore : definitions/my-api-api.yaml and dir1/dir2/*
      // $ref -> definitions/my-api-api.yaml
      var ma = path.resolve(__dirname, path.join('fixtures', 'lbapp3', 'definitions', 'my-api.yaml'));
      var maraw = fs.readFileSync(ma).toString();
      var maparsed = yaml.safeLoad(maraw);
      var maArtifact = {
        filePath: ma,
        raw: maraw,
        mtime: fs.statSync(ma).mtime,
        // even through my-api.yaml references a file that is excluded via .apicignore, we still need to load
        // refs
        refs: [ maaArtifact ],
        data: maparsed,
        name: 'my-api-product',
        type: 'product',
        version: '1.0.0',
      };
      // $ref --> ../definitions/my-api.yaml??? This isn't valid, but we're not checking here! product -> product link
      var oa1 = path.resolve(__dirname, path.join('fixtures', 'lbapp3', 'dir1', 'other-api1.yaml'));
      var oa1raw = fs.readFileSync(oa1).toString();
      var oa1parsed = yaml.safeLoad(oa1raw);
      var oa1Artifact = {
        filePath: oa1,
        raw: oa1raw,
        mtime: fs.statSync(oa1).mtime,
        data: oa1parsed,
        name: 'my-api-product',
        refs: [ ],
        type: 'product',
        version: '1.0.0',
      };

      t.deepEqual(details, [ maaArtifact, maArtifact, oa1Artifact ]);
      t.end();
    });
});

test('loadProject should not crash on invalid product', function(t) {
  var invalidProd = path.resolve(__dirname, path.join('fixtures', 'invalid-product.yaml'));
  var raw = fs.readFileSync(invalidProd).toString();
  var parsed = yaml.safeLoad(raw);

  loader.loadProject(invalidProd)
    .then(function(details) {
      t.deepEqual(details, [ {
        type: 'product',
        filePath: invalidProd,
        name: 'uber',
        version: '1.0.0',
        raw: raw,
        refs: [],
        mtime: fs.statSync(invalidProd).mtime,
        data: parsed,
      } ]);
      t.end();
    });
});

test('loadProject doesnt load subdir for non LB project', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'dir'))).then(function(details) {
    var maa = path.resolve(__dirname, path.join('fixtures', 'dir', 'my-api-api.yaml'));
    var maaraw = fs.readFileSync(maa).toString();
    var maaparsed = yaml.safeLoad(maaraw);
    var maaArtifact = {
      filePath: maa,
      raw: maaraw,
      mtime: fs.statSync(maa).mtime,
      data: maaparsed,
      name: 'my-api',
      type: 'swagger',
      version: '1.0.0',
    };

    var ma = path.resolve(__dirname, path.join('fixtures', 'dir', 'my-api.yaml'));
    var maraw = fs.readFileSync(ma).toString();
    var maparsed = yaml.safeLoad(maraw);
    var maArtifact = {
      filePath: ma,
      raw: maraw,
      data: maparsed,
      mtime: fs.statSync(ma).mtime,
      name: 'my-api-product',
      refs: [ maaArtifact ],
      type: 'product',
      version: '1.0.0',
    };

    var oa = path.resolve(__dirname, path.join('fixtures', 'dir', 'other-api.yaml'));
    var oaraw = fs.readFileSync(oa).toString();
    var oaparsed = yaml.safeLoad(oaraw);
    var oaArtifact = {
      filePath: oa,
      raw: oaraw,
      mtime: fs.statSync(oa).mtime,
      data: oaparsed,
      name: 'my-api-product',
      refs: [ maaArtifact ],
      type: 'product',
      version: '1.0.0',
    };
    t.deepEqual(details, [ maaArtifact, maArtifact, oaArtifact ]);
    t.end();
  });
});

test('loadProject loads subdir api when refed by product', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'dir2'))).then(function(artifacts) {
    var api = path.resolve(__dirname, path.join('fixtures', 'dir2', 'subdir', 'api.yaml'));
    var apiraw = fs.readFileSync(api).toString();
    var apiparsed = yaml.safeLoad(apiraw);
    var apiArtifact = {
      filePath: api,
      raw: apiraw,
      mtime: fs.statSync(api).mtime,
      data: apiparsed,
      name: 'api',
      type: 'swagger',
      version: '1.0.0',
    };

    var product = path.resolve(__dirname, path.join('fixtures', 'dir2', 'product.yaml'));
    var productraw = fs.readFileSync(product).toString();
    var productparsed = yaml.safeLoad(productraw);
    var productArtifact = {
      filePath: product,
      raw: productraw,
      data: productparsed,
      mtime: fs.statSync(product).mtime,
      name: 'product',
      refs: [ apiArtifact ],
      type: 'product',
      version: '1.0.0',
    };
    t.deepEqual(artifacts[0], apiArtifact);
    t.deepEqual(artifacts[1], productArtifact);
    t.deepEqual(artifacts, [ apiArtifact, productArtifact ]);
    t.end();
  });
});

test('loadProject loads artifacts in SSG project', function(t) {
  loader.loadProject(path.resolve(__dirname, path.join('fixtures', 'swiftserverapp')))
    .then(function(details) {
      t.deepEqual(details, [ {
        type: 'product',
        filePath: ssgp,
        mtime: ssgpmtime,
        name: 'swiftserverapp',
        data: ssgpparsed,
        raw: ssgpraw,
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: ssga,
          name: 'swiftserverapp',
          data: ssgaparsed,
          raw: ssgaraw,
          mtime: ssgamtime,
          version: '1.0.0',
        } ],
      }, {
        type: 'swagger',
        filePath: ssga,
        name: 'swiftserverapp',
        data: ssgaparsed,
        raw: ssgaraw,
        mtime: ssgamtime,
        version: '1.0.0',
      } ]);
      t.end();
    });
});

test('loadProject loads artifacts in SSG project dir', function(t) {
  var dir = path.resolve(__dirname, path.join('fixtures', 'swiftserverapp', 'dir1', 'dir2'));
  loader.loadProject(dir)
    .then(function(details) {
      t.deepEqual(details, [ {
        type: 'product',
        filePath: ssgp,
        mtime: ssgpmtime,
        name: 'swiftserverapp',
        data: ssgpparsed,
        raw: ssgpraw,
        version: '1.0.0',
        refs: [ {
          type: 'swagger',
          filePath: ssga,
          name: 'swiftserverapp',
          data: ssgaparsed,
          raw: ssgaraw,
          mtime: ssgamtime,
          version: '1.0.0',
        } ],
      }, {
        type: 'swagger',
        filePath: ssga,
        name: 'swiftserverapp',
        data: ssgaparsed,
        raw: ssgaraw,
        mtime: ssgamtime,
        version: '1.0.0',
      } ]);
      t.end();
    });
});

test('(negative) load file product that api.refs a non-existant file', function(t) {
  var invalidTestFile = path.resolve(__dirname, 'fixtures/bad-yaml', 'product-ref-not-found-api.yaml');
  return loader.loadProject(invalidTestFile)
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);
      t.equals(res[0].refs.length, 1);
      // Make sure our ref has an error
      t.ok(res[0].refs[0].err);
    });
});

test('invalid YAML in project', function(t) {
  var testDir = path.resolve(__dirname, path.join('fixtures', 'bad-yaml'));
  var invalidTestFile = path.resolve(testDir, 'bad-yaml-product.yaml');
  var validTestFile = path.resolve(testDir, 'my-api-api.yaml');
  return loader.loadProject(testDir, {})
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 4);

      var invalid = _.find(res, { filePath: invalidTestFile });
      var invalid2 = _.find(res, { filePath: path.resolve(testDir, 'doesnotexist.yaml') });
      var valid = _.find(res, { name: 'my-api' });

      t.ok(invalid);
      t.equals(invalid.err.name, 'YAMLException');

      t.ok(invalid2);
      t.equals(invalid2.err.code, 'ENOENT');

      t.equals(valid.name, 'my-api');
      t.equals(valid.filePath, validTestFile);
    });
});

test('Invalid YAML with tab indent', function(t) {
  var invalidTabFile = path.resolve(__dirname, path.join('fixtures', 'invalid-tab-indent_1.yaml'));
  var raw = fs.readFileSync(invalidTabFile).toString();
  return loader.loadProject(invalidTabFile, {}).then(function(res) {
    t.ok(res);
    t.equals(res.length, 1);
    var invalid = res[0];
    t.equals(invalid.filePath, invalidTabFile);
    t.equals(raw, invalid.raw);
    t.match(invalid.err.name, 'YAMLException');
  });
});

test('Valid YAML with tab indent', function(t) {
  var validTabFile = path.resolve(__dirname, path.join('fixtures', 'valid-api-with-tabs.yaml'));
  return loader.loadProject(validTabFile, {}).then(function(res) {
    t.ok(res);
    t.equals(res.length, 1);
    var invalid = _.find(res, 'err');
    t.notOk(invalid);
  });
});

test('return [] for dir w/zero YAML files', function(t) {
  return loader.loadProject(path.resolve(__dirname, path.join('..', 'lib')))
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 0);
    });
});

test('load empty file', function(t) {
  return loader.loadProject(path.resolve(__dirname, 'fixtures', 'empty-file.bzz'))
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);
      t.ok(res[0].err.message, f('Encountered an empty file %s.', 'empty-file.bzz'));
    });
});

test('load yaml, non-product/api', function(t) {
  return loader.loadProject(path.resolve(__dirname, 'fixtures', 'omcd.yaml'), { extensions: true })
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);
      t.ok(res[0].err.message, f('Encountered a file that is not a product or api %s.', 'omcd.yaml'));
    });
});

test('load product w/ cycles', function(t) {
  t.comment('Make sure we can load a product that has a cycle in $refs. It is not valide per se, but ' +
    'ensure that we can load without problems');
  var file = path.resolve(__dirname, 'fixtures', 'ref-cycles', 'product-a.yaml');
  return loader.loadProject(file, { validate: true, extensions: true })
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);

      var productName = res[0].name;
      var refProductName = res[0].refs[0].name;
      // This is sort of a silly test, but make sure that the root product and the referred to is the same name?
      t.equals(productName, refProductName);
    });
});

test('load product w/ resovleExternalApiRefs', function(t) {
  t.comment('Make sure we can load a product that has a cycle in $refs. It is not valide per se, but ' +
    'ensure that we can load without problems');
  var file = path.resolve(__dirname, 'fixtures/lbapp-refs/definitions/my-api.yaml');
  return loader.loadProject(file, { resolveExternalApiRefs: true })
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);

      var refLoadedDesc = res[0].refs[0].data.info.description;
      t.equals(refLoadedDesc, 'description-fragment');
    });
});

test('load product w/ no apis', function(t) {
  var file = path.resolve(__dirname, 'fixtures/product-no-apis.yaml');
  return loader.loadProject(file, { resolveExternalApiRefs: true })
    .then(function(res) {
      t.ok(res);
      t.equals(res.length, 1);
      t.equals(res[0].refs.length, 0);
    });
});

