// Copyright IBM Corp. 2015,2016. All Rights Reserved.
// Node module: apiconnect-collective-jmx
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var Encoder = require('./encoder');
var Payload = require('./payload');
var _ = require('lodash');
var encodeLiberty = require('./util').encodeLibertyPath;
var jmxTypes = require('./encoder').types;
var mandatory = require('./util').mandatory;

// MBeans
var APIC_CLUSTER_PATH = '/sys.wlpn.internal';

var CLUSTER_MEMBER = 'WebSphere%3Afeature%3DclusterMember%2Ctype%3D' +
'ClusterMember%2Cname%3DClusterMember';

var SCALING_MEMBER = encodeURIComponent('WebSphere:feature=scalingMember,' +
  'type=ScalingMember,name=ScalingMember');

var CLUSTER_TREE_PATH = '/sys.was.groups/types/cluster';

var CLUSTER_MBEAN_PATH = '/IBMJMXConnectorREST/mbeans/' +
  encodeURIComponent('WebSphere:feature=collectiveController,' +
    'type=ClusterManager,name=ClusterManager') + '/operations';

var COLLECTIVE_MBEAN_PATH = '/IBMJMXConnectorREST/mbeans/' +
  'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository/operations';

var CREATE = '/IBMJMXConnectorREST/mbeans/' +
'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/create';

var DELETE = '/IBMJMXConnectorREST/mbeans/' +
'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/delete';

var EXISTS = '/IBMJMXConnectorREST/mbeans/' +
'WebSphere%3Afeature%3DcollectiveController%2Cname%3D' +
  'CollectiveRepository%2Ctype%3DCollectiveRepository' +
  '/operations/exists';

var GET_DESC = '/IBMJMXConnectorREST/mbeans/' +
'WebSphere%3Afeature%3DcollectiveController%2Cname%3DCollectiveRepository' +
'%2Ctype%3DCollectiveRepository/operations/getDescendantData';

// Export for tests
exports._endpoints = {
  APIC_CLUSTER_PATH: APIC_CLUSTER_PATH,
  CLUSTER_MEMBER: CLUSTER_MEMBER,
  CLUSTER_TREE_PATH: CLUSTER_TREE_PATH,
  CREATE: CREATE,
  DELETE: DELETE,
  EXISTS: EXISTS,
  GET_DESC: GET_DESC,
};

exports.CreateCluster = CreateCluster;
exports.DeleteCluster = DeleteCluster;
exports.DeleteMemberClusterFeature = DeleteMemberClusterFeature;
exports.DeleteMemberClusterMBean = DeleteMemberClusterMBean;
exports.DeleteMemberScalingFeature = DeleteMemberScalingFeature;
exports.DeleteMemberScalingMBean = DeleteMemberScalingMBean;
exports.Exists = Exists;
exports.GetDescendantData = GetDescendantData;
exports.Register = Register;
exports.SetMemberClusterFeature = SetMemberClusterFeature;
exports.SetMemberClusterMBean = SetMemberClusterMBean;
exports.SetMemberScalingFeature = SetMemberScalingFeature;
exports.SetMemberScalingMBean = SetMemberScalingMBean;
exports.Unregister = Unregister;
exports.formatIdentity = formatIdentity;
exports.getClusterFeature = getClusterFeature;
exports.getClusterIdentity = getClusterIdentity;
exports.getClusterMbean = getClusterMBean;
exports.getClusterName = getClusterName;
exports.getClusterPath = getClusterPath;
exports.getKeyByIdentity = getKeyByIdentity;
exports.listClusterData = listClusterData;
exports.listClusterMembers = listClusterMembers;
exports.listClusterNames = listClusterNames;
exports.listMembers = listMembers;
exports.stopCluster = stopCluster;
exports.startCluster = startCluster;
exports.removeClusterPrefix = removeClusterPrefix;

/**
 * Create a new cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function CreateCluster(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();

  var mbeanResource = '/sys.was.groups/types/cluster/' + options.clusterName;
  encoder.addString(mbeanResource);
  encoder.addSimpleValue(null, null, jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Register with a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function Register(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();

  var tuple = [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');

  var mbeanResource = '/sys.was.groups/types/cluster/' +
    options.clusterName + '/sys.members/' + tuple;

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(null, null, jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Unregister from a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function Unregister(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();

  var tuple = [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');

  var mbeanResource = '/sys.was.groups/types/cluster/' +
    options.clusterName + '/sys.members/' + tuple;

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
}

/**
 * Delete a cluster in the Collective Repository.
 * @param {object} options - The options object.
 * @param {string} options.clusterName - The name of the cluster to delete.
 */
function DeleteCluster(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();

  var mbeanResource = '/sys.was.groups/types/cluster/' + options.clusterName;
  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
}

/**
 * Add or change a member's cluster.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function SetMemberClusterMBean(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getClusterMBean(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(options.clusterName, jmxTypes.String,
    jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Change a member server's cluster membership on a target collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function SetMemberClusterFeature(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getClusterFeature(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(options.clusterName, jmxTypes.String,
    jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Remove a member's cluster.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function DeleteMemberClusterMBean(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getClusterMBean(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member server's cluster membership on a target collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the cluster to set.
 */
function DeleteMemberClusterFeature(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getClusterFeature(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Add or change a member's scaling configuration.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @param {string} options.scalingMember - boolean value to set if scalable
 */
function SetMemberScalingMBean(options) {
  checkMandatory(options, 'missing options');
  mandatory(options.scalingEnable, 'missing scalingEnable');

  var encoder = new Encoder();
  var mbeanResource = getScalingMBean(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(options.scalingEnable.toString(), jmxTypes.String,
    jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Change a member server's type of scaling feature.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 * @param {string} options.scalingFeature - type of scaling feature
 */
function SetMemberScalingFeature(options) {
  checkMandatory(options, 'missing options');
  mandatory(options.scalingType, 'missing scalingType');
  var encoder = new Encoder();
  var mbeanResource = getScalingFeature(options);

  encoder.addString(mbeanResource);
  encoder.addSimpleValue(options.scalingType, jmxTypes.String,
    jmxTypes.JavaObject);
  return new Payload(CREATE, 'POST', encoder.encodeJson());
}

/**
 * Remove a member's auto-scaling feature.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 */
function DeleteMemberScalingMBean(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getScalingMBean(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Remove a member's auto-scaling type.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @param {string} options.clusterName - The name of the member's cluster.
 */
function DeleteMemberScalingFeature(options) {
  checkMandatory(options, 'missing options');
  var encoder = new Encoder();
  var mbeanResource = getScalingFeature(options);

  encoder.addString(mbeanResource);
  return new Payload(DELETE, 'POST', encoder.encodeJson());
};

/**
 * Retrieve a list of descendant data elements from the CollectiveRepository
 * based on the specified node.
 * @param {string} node - The string that represents the node to query for
 * child nodes, represented in a path-like format.
 * (eg. /sys.was.groups/types/cluster).
 * @returns {object} - A hash of nodes and their values (if applicable).
 */
function GetDescendantData(node) {
  var encoder = new Encoder();
  encoder.addString(node);
  return new Payload(GET_DESC, 'POST', encoder.encodeJson());
}
/**
 * Check whether or not the CollectiveRepository node exists.
 * @param {string} node - The string that represents the node to query for
 * child nodes, represented in a path-like format.
 * @returns {object} - A JMX payload for querying a CollectiveRepository.
 */
function Exists(node) {
  var encoder = new Encoder();
  encoder.addString(node);
  return new Payload(EXISTS, 'POST', encoder.encodeJson());
}

/**
 * Returns the formatted string that uniquely identifies a server within a
 * Collective.
 * @param {object} options - The options object.
 * @param {string} options.hostName - The hostname of the member.
 * @param {string} options.userDir - The path on the host to the 'usr'
 * folder that contains the member.
 * @param {string} options.serverName - The name of the member.
 * @return {String} - The encoded identity string.
 */
function formatIdentity(options) {
  mandatory(options.hostName, 'options.hostName is required!');
  mandatory(options.userDir, 'options.userDir is required!');
  mandatory(options.serverName, 'options.serverName is required!');

  return [
    options.hostName.toLowerCase(),
    encodeLiberty(options.userDir),
    options.serverName,
  ].join(',');
}

/**
 * Takes a CollectiveRepository tree key (in path-like format) that represents
 * a cluster and returns the cluster name.
 * @param {string} treeKey - The CollectiveRepository key.
 * @returns {string|null} - Returns a name, or null if no name is found.
 */
function getClusterName(treeKey) {
  if (!treeKey)
    return null;
  var match = treeKey.match(/cluster\/(.*)\/sys.members/i);
  return (match && match[1]) ? match[1] : null;
}

/**
 * Takes a CollectiveRepository tree key (in path-like format) that represents
 * a cluster and returns the cluster name.
 * @param {string} treeKey - The CollectiveRepository key.
 * @returns {string|null} - Returns a server identity,
 * or null if no identity is found.
 */
function getClusterIdentity(treeKey) {
  if (!treeKey)
    return null;
  var match = treeKey.match(/cluster\/sys.members\/(.*)/i);
  // Only the first item matters.
  return (match && match[1]) ? match[1].split('/')[0] : null;
}

/**
 * Takes a CollectiveRepository tree and returns a list of cluster identities.
 * @param tree - The hash of CollectiveRepository keys.
 * @param clusterName - The name of the cluster to search the keys for.
 * @returns {Array} - An array of cluster member identities.
 */
function listClusterMembers(tree, clusterName) {
  mandatory(tree, 'You must provide a non-null tree!');
  mandatory(clusterName, 'You must provide a clusterName parameter!');
  var identities = [];
  var payload;
  // If they pass the entire object, we'll assign the value property to payload.
  if (tree.value)
    payload = tree.value;
  else
    payload = tree;
  if (payload) {
    var keys = Object.getOwnPropertyNames(payload);
    _.forEach(keys, function(key) {
      var name = getClusterName(key);
      if (name === clusterName) {
        var id = getClusterIdentity(key);
        if (id)
          identities.push(id);
      }
    });

  }
  return identities;
}

/**
 * Find the first key that contains the given server identity.
 * @param tree - The hash of CollectiveRepository keys.
 * @param identity - The name of the server identity to search for.
 * @returns {string|null} - The key which contains the identity, or null if none
 * exists.
 */
function getKeyByIdentity(tree, identity) {
  mandatory(tree, 'You must provide a non-null tree!');
  mandatory(identity, 'You must provide an identity!');
  var payload;
  if (tree.value)
    payload = tree.value;
  else
    payload = tree;

  var keys = Object.getOwnPropertyNames(payload);
  return _.find(keys, function(key) {
    return _.contains(key, identity);
  });
}

/**
 * Generate the resource string for getClusterMBean operations.
 * @param options
 * @returns {string}
 */
function getClusterMBean(options) {
// Generate the internal resource path (not the URL's path!)
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.mbeans',
    CLUSTER_MEMBER,
    'attributes/Name',
  ].join('/');
  return mbeanResource;
}

/**
 * Generate the resource string for getClusterFeature operations.
 * @param options
 * @returns {string}
 */
function getClusterFeature(options) {
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.features/data/clusterMember/name',
  ].join('/');
  return mbeanResource;
}

/**
 * Generate the resource string for scaling MBean operations.
 * @param options
 * @returns {string}
 */
function getScalingMBean(options) {
// Generate the internal resource path (not the URL's path!)
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.mbeans',
    SCALING_MEMBER,
    'attributes/Enabled',
  ].join('/');
  return mbeanResource;
}

/**
 * Gets list of stored data for a cluster.
 * @param clusterName - The name of the cluster identity to search for.
 */
function listClusterData(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  var mbeanResource = getClusterPath(options);
  encoder.addString(mbeanResource);
  return new Payload([COLLECTIVE_MBEAN_PATH, 'getDescendantData'].join('/'),
    'POST', encoder.encodeJson());
}

/**
 * Generate the resource string for scaling feature operations.
 * @param {string} options.hostName - name of host
 * @param {string} options.userDir - directory of server on member host
 * @param {string} options.serverName - name of server
 * @returns {string}
 */
function getScalingFeature(options) {
  var mbeanResource = [
    '/sys.was.collectives/local/hosts',
    options.hostName.toLowerCase(),
    'userdirs',
    encodeLiberty(options.userDir),
    'servers',
    options.serverName,
    'sys.features/data/scalingMember/mode/child',
  ].join('/');
  return mbeanResource;
}

/**
 * Generate the resource string for cluster environment path
 * @param {string} options.clusterName - name of cluster
 * @returns {string}
 */
// FIXME rename to getClusterEnvPath
function getClusterPath(options) {
  mandatory(options.clusterName, 'clusterName is required!');
  return [
    APIC_CLUSTER_PATH,
    'cluster',
    options.clusterName,
    'env',
  ].join('/');
}

/**
 * Removes path prefix from returned data when getting environment variables.
 * @param {string} options.clusterName - name of cluster
 * @returns {string}
 */
function removeClusterPrefix(options, data) {
  mandatory(options.clusterName, 'missing clusterName');
  var path = getClusterPath(options);

  var regex = new RegExp(path + '\/', 'gi');
  data = JSON.parse(JSON.stringify(data)
    .replace(regex, ''));
  // MBeans always gives us a null value and key is root of path, we clean
  // up by deleting.
  delete data[path];
  return data;
}

function checkMandatory(options) {
  mandatory(options.hostName, 'missing hostName');
  mandatory(options.userDir, 'missing userDir');
  mandatory(options.serverName, 'missing serverName');
  mandatory(options.clusterName, 'missing clusterName');
}

/**
 * Starts all members registered to a cluster
 * @param {string} options.clusterName - name of cluster
 */
function startCluster(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  encoder.addString('');
  return new Payload([CLUSTER_MBEAN_PATH, 'startCluster'].join('/'),
    'POST', encoder.encodeJson());
}

/**
 * Stops all members registered to a cluster. This is a simple stop, if a
 * scaling policy exists, it may cause all the members to be started again.
 * This is useful, it provides a robust way of implementing "restart" for
 * auto-scaled clusters. If the cluster is auto-scaled, to permanently stop a
 * cluster, a new scalingPolicy must be uplaoded to the controller with an
 * `enabled="false"` attribute.
 * @param {string} options.clusterName - name of cluster
 */
function stopCluster(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  encoder.addString('');
  return new Payload([CLUSTER_MBEAN_PATH, 'stopCluster'].join('/'),
    'POST', encoder.encodeJson());
}

/**
 * List all members of a cluster
 * @param {string} options.clusterName - name of cluster
 */
function listMembers(options) {
  mandatory(options.clusterName, 'missing clusterName');
  var encoder = new Encoder();
  encoder.addString(options.clusterName);
  return new Payload([CLUSTER_MBEAN_PATH, 'listMembers'].join('/'),
    'POST', encoder.encodeJson());
}

/**
 * List all clusters registered with controller
 */
function listClusterNames(options) {
  var encoder = new Encoder();
  return new Payload([CLUSTER_MBEAN_PATH, 'listClusterNames'].join('/'),
    'POST', encoder.encodeJson());
}
