# API Connect WSDL

## Getting Started
To get up and running with a this module, just require it in your mode module:

```javascript
var apicWsdl = require("apiconnect-wsdl");
```

Build and Release information is located in the [wiki](https://github.ibm.com/apimesh/apiconnect-wsdl/wiki)

This repo also contains a cli (called wpcli) which is a convenient way to execute the major parser functions from a command line.  See  [wiki](https://github.ibm.com/apimesh/apiconnect-wsdl/wiki)


## Apis

### create

```javascript
/**
 * Create an openapi from wsdl
 * @param {Buffer or String file location or String url} wsdl or zip content
 * @param {String} serviceName name of the wsdl service
 * @param {String} wsdlId id to use in the generated swagger.  Often this is the filename
 * @param options
 *     type: 'wsdl' (default) or 'wsdl-to-rest'
 *     openapiVersion: '2.0' (default) or '3.0'
 *     allowExtraFiles: false (default) or true
 *     defaults: object to merge into openapi after generation.  Same shape as openapi
 *     auth: auth object if wsdl is protected url
 *     mapOptions: setting to use for autogenerated assembly map. The default is no map.options
 *         mapOptions.includeEmptyXMLElements
 *         mapOptions.namespaceInheritance
 *         mapOptions.inlineNamespaces
 * @return {
 *              openapi: <openapi>
 *              statistics: { various stats}
 *              messages: [ {message: <info message>}* ]
 *         }
 */
function createOpenApi(wsdl, serviceName, wsdlId, options)
```
Creates an openapi from a wsdl.
  - The wsdl can be a Buffer containing the wsdl/zip contents or a url/filepath.
  - The serviceName is the name of the service within the wsdl for this created api.
  - The openapiversion is 2.0 or the new 3.0 version
  - The type is 'wsdl' (for wsdl proxy) or 'wsdl-to-rest' (SOAP->REST)
  - The create api has its own defaults for various fields.  You can provide your own overrides.

```javascript
  let result = await.apicWsdl.create(buffer, serviceName, filename,
	 {
     type: 'wsdl',
     openapiVersion: version,
     defaults: {
       securityDefinitions: {
         clientIdHeader: {
          type: 'apiKey',
          in: 'header',
          name: 'X-IBM-Client-Id',
         }
       },
       security: [ {
         clientIdHeader: []
       } ],
       'x-ibm-configuration': {
          cors: {
            enabled: false
          },
       }
     }
	 });
  // The openapi is within result.openapi

```

### validateWSDL

```javascript
/**
* Validates wsdl and rejects with error containing messages.
* @error { "message": <combined message>
*          messages[ {message: <message>}* ]
*        }
* @param locationOrContent location of WSDL or Buffer
* @param options auth and other options.
* @returns promise of serviceData
*/
function validateWSDL(locationOrContent, options);
```
The validateWSDL method will parse the wsdl/zip and perform some additional semantic validation of the wsdl.  Thrown errors list the individual messages

```javascript
  try {
    await.apicWsdl.validateWSDL(buffer);
	catch (err) {
		// Process messages
	}
```

### validateXSD

```javascript
/**
* Validates xsd and rejects with error containing messages.
* @error { "message": <combined message>
*          messages[ {message: <message>}* ]
*        }
* @param locationOrContent location of XSD or Buffer
* @param options auth and other options.
* @returns promise of serviceData
*/
function validateXSD(locationOrContent, options);
```
The validateWSDL method will parse the xsd/zip and perform some additional semantic validation of the xsd.  Thrown errors list the individual messages

```javascript
  try {
    await.apicWsdl.validateXSD(buffer);
	catch (err) {
		// Process messages
	}
```

### introspectWSDL

```javascript
/**
* Introspect wsdl and rejects with error containing messages.
* @error { "message": <combined message>
*          messages[ {message: <message>}* ]
*        }
* @param locationOrContent location of WSDL or Buffer
* @param options auth and other options.
* @returns promise of serviceData
*/
function introspectWSDL(locationOrContent, options)...
```
The introspectWSDL api is used to determine which services are in the 
wsdl.

```javascript
Example Response
{ portTypes: 
   { MyPortTypeType: 
      [ { name: 'getStuff', description: undefined },
        { name: 'doStuff', description: undefined } ] },
  bindings: 
   { MySOAPBinding: 
      { type: 'MyPortType',
        operations: [ 'getStuff', 'doStuff' ] } },
  services: 
   [ { service: 'MyService',
       filename: 'MyWSDL_1.0.0.wsdl',
       operations: 
        [ { operation: 'getStuff' },
          { operation: 'doStuff' } ] } ] }
```

```javascript
  try {
    let serviceData = await.apicWsdl.introspectWSDL(buffer);
	catch (err) {
		// Process serviceData
	}
```

### addTargetOpenApi

```javascript
//**
* addTargetOpenApi
* @param openApi - existing openApi
* @param wsdl - Buffer containing the wsdl/zip or location of the wsdl/zip
* @param wsdlServiceName - Service
* @return promise openApi
*/
function addTargetOpenApi(openapi, wsdl, wsdlServiceName) ..
```
The addTargetOpenApi api is used to add a target service into an existing openapi. 
  - The openapi is the existing openapi (version 2.0 or 3.0)
	- The wsdl is a Buffer, wsdl/zip file location or URL
	- The wsdl service is the name of the target service in the wsdl
	- returns an openapi with the embedded target service.


```javascript
    let updated_openapi = await.apicWsdl.addTargetOpenApi(openapi, wsdl, service);
```

### addXSDToTargetOpenApi

```javascript
/**
* addXSDToTargetOpenApi
* @param openApi - existing openApi
* @param xsd - Buffer containing the xsd or location of the xsd
* @param wsdlServiceName - Service
* @return promise openApi
*/
function addTargetOpenApi(openapi, xsd, wsdlServiceName) ..
```
The addXSDToTargetOpenApi api is used to add xsd definitions to a target service within an existing openapi. 
  - The openapi is the existing openapi (version 2.0 or 3.0)
	- The xsd is a Buffer, xsd/zip file location or URL
	- The wsdl service is the name of the target service in the wsdl
	- returns an openapi with the embedded target service.


```javascript
    let updated_openapi = await.apicWsdl.addXSDToTargetOpenApi(openapi, xsd, service);
```

### injectServiceEndpointsIntoWSDLorZIP
```javascript
/**
* @param inContent wsdl or zip content (Buffer or String)
* @param serviceEndpoints single or array of endpoint strings
* @param serviceName the wsdl-definition.service string.
* @return (Promise)
*   outContent: wsdl or zip content in a Buffer
*   filename: if zip mode, this is the full name of first wsdl modified within the zip
*   stringContent: in zip mode, this is the string content of filename.
*                  in wsdl mode, this is the string content of the wsdl file
*/
function injectServiceEndpointsIntoWSDLorZIP(inContent, serviceEndpoints, serviceName)..
```
Use this method to add endpoints into a wsdl/zip file stored on apim.
This is used dynamically in the portal when a wsdl is requested.


## Older methods

### apicWsdl.getJsonForWSDL(location, auth) - get a JSON representation of the WSDL from the file, in memory content or URL at location 

```javascript
var promise = apicWsdl.getJsonForWSDL("sample.wsdl");
promise.then(function(allWSDLs) {
	// TODO process allWSDLs array of WSDL objects
}, function(error) {
	console.log(error.message);
});
```


Returns a promise that will resolve when the fetch and parse is complete. The location can be a standalone WSDL file, a ZIP file containing a complete set of WSDLs and dependent XSDs, in memory content, or a URL that can point to either a WSDL or ZIP file. (If the location starts with "<?xml" the logic assumes in-memory content). Auth is an optional parameter that must be a pre-encoded Basic auth header value.

The success function will be called with an argument that is an array of all the root WSDL objects found at the location. Each array element consists of the following:

```javascript
var wsdlFile = {
	filename: filename,
	type: "wsdl",	// can be "wsdl or "xsd"
	json: json	// the parsed WSDL in JSON format
};
```


### apicWsdl.getWSDLServices(allWSDLs) - get a list of all the services in the supplied list of WSDL objects 

```javascript
var promise = apicWsdl.getJsonForWSDL("sample.wsdl");
promise.then(function(allWSDLs) {
	var serviceData = apicWsdl.getWSDLServices(allWSDLs);
	// TODO list of services is in serviceData.services
}, function(error) {
	console.log(error.message);
});
```

Returns an object that contains an array of the services found from the supplied array of WSDL objects. Each service object consists of the following:

```javascript
var service = {
	operations: [{	// array of all operations for the service
		operation: "operationName"
	}],
	service: "serviceName",
	filename: "originalFilename"
};
```

### apicWsdl.findWSDLForServiceName(allWSDLs, serviceName, serviceFilename) - convenience method to find the WSDL that matches the service name 

```javascript
var serviceName = "myServiceName";
var promise = apicWsdl.getJsonForWSDL("sample.wsdl");
promise.then(function(allWSDLs) {
	var wsdlEntry = apicWsdl.findWSDLForServiceName(allWSDLs, serviceName);
	// TODO wsdlEntry can be passed into getSwaggerForService()
}, function(error) {
	console.log(error.message);
});
```

The serviceFilename is optional and can be used as an additional means of narrowing down the choice of WSDL. This filename would typically be the value of the filename returned from the call to getWSDLServices().

### apicWsdl.getSwaggerForService(wsdlEntry, serviceName, wsdlId) - get the Swagger representation of the WSDL for the given service 

```javascript
var serviceName = "myServiceName";
var wsdlId = "myUniqueID";
var promise = apicWsdl.getJsonForWSDL("sample.wsdl");
promise.then(function(allWSDLs) {
	var wsdlEntry = apicWsdl.findWSDLForServiceName(allWSDLs, serviceName);
	var swagger = apicWsdl.getSwaggerForService(wsdlEntry, serviceName, wsdlId);
	// TODO the swagger object can be passed to js-yaml safeDump() method to get pure YAML output
}, function(error) {
	console.log(error.message);
});
```

Returns a promise that will resolve when the modification of the service endpoint is complete. The wsdlEntry can be a standalone WSDL or XSD file, a ZIP file containing a complete set of WSDLs and dependent XSDs. The serviceEndpoint is the value of the endpoint that should be put in the address of the wsdl port.

The success function will be called with an argument that contains a JSON object with an associative array of filename for the modified files and their content.

## Apis for Testing
### apicWsdl.sniffSwagger(swagger) - inspect the swagger representation too look for errors or problems.

Returns a promise that will resolve if there are no problems found in the swagger.  The promise is rejected if problems are encountered.  The following checks are performed (but this may be expanded in the future):
* The swagger is run through a swagger parser to ensure that it is valid.
* Examples in the swagger are parsed with a dom parser to validate.
* The swagger is inspected to see if the term "undefined" is used (which is an indication that something went wrong).

### apicWsdl.setServiceEndpoint(wsdlEntry, serviceEndpoint) - get the Swagger representation of the WSDL for the given service 

```javascript
promise.then(function(allWSDLs) {
	var modifiedInstall = apicWsdl.setServiceEndpoint(wsdlEntry, serviceEndpoint);
}, function(error) {
	console.log(error.message);
});
```

### apicWsdl.updateSwagger(swagger1, swagger2) - Intelligently return original swagger1 with updates from swagger2

Parameter swagger1 is the json for a swagger file (i.e. customer's current open api that contains an api assembly etc).
Parameter swagger2 is the json for a new swagger file.  
 - For example swagger2 might be a generated from a new version of the wsdl service.
 - For example swagger2 might be a the same wsdl service but generated with a new version of the parser.
 
The updateSwagger function returns an updated swagger.  It searches for the wsdl services in swagger1 (both the root api and implementation services),
and replaces them with the services of the same name from swagger2.  The paths and definitions are smartly updated, and the other stuff (for example the assembly) 
is untouched.  It also supports no-wsdl updates.  If neither swagger is from a wsdl, then it updates the paths and definitions.

### apicWsdl.getDefinitionsForXSD(location, auth, rootElementList) - returns the swagger definitions for the root elements.

```javascript
var promise = apicWsdl.getDefinitionsForXSD("sample.xsd");
promise.then(function(definitions) {
	// TODO process swagger.definitions
}, function(error) {
	console.log(error.message);
});
```

Returns a promise that will resolve when the fetch and parse is complete. The location can be a XSD file, a ZIP file containing a complete set of WSDLs and dependent XSDs, or a URL that can point to either an XSD, or ZIP file. Auth is an optional parameter that must be a pre-encoded Basic auth header value. All of the root elements in the files (and their dependencies) are returned in the swagger definitions.  If the rootElementList is present and not empty, then only the root elements in the list (and their dependencies) are returned.

The success function will be called with an argument that contains a JSON object with an associative array of definitions that were found.
