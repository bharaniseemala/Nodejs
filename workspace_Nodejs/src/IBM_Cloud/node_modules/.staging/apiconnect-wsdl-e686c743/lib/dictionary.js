/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Dictionary creation and access functions
**/
const u = require('../lib/utils.js');
const RESERVED_DEF = u.RESERVED_DEF;

/*
* Walk the schemaList provided by node.soap and return a flat dictionary.
* The node.soap schema is accessed by dict.dictEntry[nsName] where nsName
* is <name>_<prefix>. The <name> is the name of the xml or soap construct and <prefix> is the
* prefix defined for the namespace which defines the construct.
*/
function buildDictionary(schemaList, detectedWSAddressing, namespaces, wsdlTNS) {
    let dictEntry = {};
    let groups = {};
    let attrGroups = {};
    let elementLinkup = {};
    let attrLinkup = {};
    let substitutions = {};
    let elementNS = {};
    let originalNames = {};
    let hiddenTypes = {};
    addPredefinedNSNames(dictEntry, detectedWSAddressing);

    let schemaLen = schemaList.length;
    for (let i = 0; i < schemaLen; i++) {
        // schema is the node.soap schema
        let schema = schemaList[i];

        // Get the targent namespace and the qualification of elements and attributes
        let schemaTNS = '';
        let qualified = false;
        let qualifiedAttr = false;
        if (schema['undefined']) {
            if (schema['undefined'].targetNamespace) {
                schemaTNS = schema['undefined'].targetNamespace;
            }
            if (schema['undefined'].elementFormDefault && schema['undefined'].elementFormDefault == 'qualified') {
                qualified = true;
            }
            if (schema['undefined'].attributeFormDefault && schema['undefined'].attributeFormDefault == 'qualified') {
                qualifiedAttr = true;
            }
        }
        let prefix = u.getPrefixForNamespace(schemaTNS, schema.wsdlXmlns ? schema.wsdlXmlns : namespaces);

        if ('redefine' in schema) {
            annotateWithParserMessage(dictEntry[RESERVED_DEF].schema, 'The redefine element and its contents are ignored.');
        }
        if ('notation' in schema) {
            annotateWithParserMessage(dictEntry[RESERVED_DEF].schema, 'The notation element is ignored.');
        }
        if (schema.complexType) {
            let defComplexTypes = u.makeSureItsAnArray(schema.complexType);
            let complexLen = defComplexTypes.length;
            for (let j = 0; j < complexLen; j++) {
                let complexType = defComplexTypes[j];
                let nsName = resolveNsName(complexType['undefined'].name, schemaTNS, namespaces);
                originalNames[nsName] = {
                    prefix: prefix,
                    name: u.stripNamespace(complexType['undefined'].name)
                };
                dictEntry[nsName] = {
                    schema: complexType,
                    schemaType: 'complex',
                    tns: schemaTNS,
                    qualified: qualified,
                    qualifiedAttr: qualifiedAttr,
                    xmlns: schema.xmlns
                };
            }
        }
        if (schema.simpleType) {
            let defSimpleTypes = u.makeSureItsAnArray(schema.simpleType);
            let simpleLen = defSimpleTypes.length;
            for (let j = 0; j < simpleLen; j++) {
                let simpleType = defSimpleTypes[j];
                let nsName = resolveNsName(simpleType['undefined'].name, schemaTNS, namespaces);
                originalNames[nsName] = {
                    prefix: prefix,
                    name: u.stripNamespace(simpleType['undefined'].name)
                };
                dictEntry[nsName] = {
                    schema: simpleType,
                    schemaType: 'simple',
                    tns: schemaTNS,
                    qualified: qualified,
                    qualifiedAttr: qualifiedAttr,
                    xmlns: schema.xmlns
                };
                if (simpleType.list) {
                    // xsd:list is a whitespace delimited string of the types defined in the itemType attribute.
                    // This is an uncommon usage, and the best approach is to map to a string.
                    let xsdPrefixes = getXSDPrefixes(namespaces);
                    let stringType = xsdPrefixes.length > 0 ? xsdPrefixes[0] + ':string' : 'string';
                    dictEntry[nsName].schema['undefined'].type = stringType;
                }
            }
        }
        if (schema.element) {
            let defElements = u.makeSureItsAnArray(schema.element);
            let elemLen = defElements.length;
            for (let j = 0; j < elemLen; j++) {
                let element = defElements[j];
                let elemName = element['undefined'].name;
                let nsName = elemName;
                if (schemaTNS) {
                    nsName = elemName + '_' + prefix;
                }
                // Detect collision between this element and a type of the same name.
                // If they represent different content, then put the hidden type in
                // a list so that it can be given a mangled name.
                if (dictEntry[nsName]  && !elementNS[nsName]) {
                    let typeNsName = element['undefined'].type ?
                        resolveNameInNamespace(element['undefined'].type, schema.xmlns, namespaces, schemaTNS) : '';

                    if (nsName !== typeNsName) {
                        hiddenTypes[nsName] = u.deepClone(dictEntry[nsName]);
                    }
                }

                // capture element namespaces
                if (nsName) {
                    elementNS[nsName] = {
                        ns: schemaTNS,
                        prefix: prefix
                    };
                    originalNames[nsName] = {
                        prefix: prefix,
                        name: elemName
                    };
                }

                if (!('complexType' in element) &&
                      !('simpleType' in element) &&
                      !(element['undefined'] &&
                          (element['undefined'].type || element['undefined'].substitutionGroup))) {
                    // Special case of <xsd:element name="foo" />
                    // This is treated as element with name foo of anyType
                    dictEntry[nsName] = {
                        schema: null,
                        schemaType: 'anyType',
                        suppressXSIType: true,
                        tns: schemaTNS,
                        qualified: qualified,
                        xmlns: schema.xmlns
                    };
                }
                if ('complexType' in element) {
                    // Special case of complexType that is empty
                    if (!element.complexType) {
                        element.complexType = {};
                    }
                    if (!dictEntry[nsName]) {
                        dictEntry[nsName] = {
                            schema: element.complexType,
                            schemaType: 'complex',
                            tns: schemaTNS,
                            qualified: qualified,
                            qualifiedAttr: qualifiedAttr,
                            xmlns: schema.xmlns
                        };
                    }
                } else if (element.simpleType) {
                    if (!dictEntry[nsName]) {
                        dictEntry[nsName] = {
                            schema: element.simpleType,
                            schemaType: 'simple',
                            tns: schemaTNS,
                            qualified: qualified,
                            qualifiedAttr: qualifiedAttr,
                            xmlns: schema.xmlns
                        };
                    }
                } else {
                    var isXSD = isXSDType(element['undefined'].type, namespaces, schema.xmlns);
                    var isAnyType = isXSDAnyType(element['undefined'].type, namespaces, schema.xmlns);

                    if (isAnyType) {
                        dictEntry[nsName] = {
                            schema: null,
                            schemaType: 'anyType',
                            suppressXSIType: true,
                            tns: schemaTNS,
                            qualified: qualified,
                            xmlns: schema.xmlns
                        };
                    } else if (isXSD) {
                        // element is a primitive type - generate a fake simple type
                        if (!dictEntry[nsName]) {
                            dictEntry[nsName] = {
                                schema: {
                                    undefined: {
                                        name: elemName
                                    },
                                    restriction: {
                                        undefined: {
                                            base: element['undefined'].type
                                        }
                                    }
                                },
                                schemaType: 'simple',
                                suppressXSIType: true, // Suppress XSIType for primitives
                                tns: schemaTNS,
                                qualified: qualified,
                                qualifiedAttr: qualifiedAttr,
                                xmlns: schema.xmlns
                            };
                        }
                    } else {
                        let elemType = resolveNameInNamespace(element['undefined'].type, schema.xmlns, namespaces, schemaTNS);
                        if (elemType) {
                            if (elemType != nsName) {
                                // create an element type lookup to be fixed up after we've got all the dictEntry
                                elementLinkup[nsName] = elemType;
                            } else {
                                element['undefined'].linkup = elemType;
                            }
                        }
                    }
                }
                if (element['undefined'].substitutionGroup) {
                    // record the substitution group information in a map
                    let group = resolveNameInNamespace(element['undefined'].substitutionGroup, schema.xmlns, namespaces, schemaTNS);
                    let subElemType;

                    if (!element['undefined'].type && !element.complexType && !element.simpleType) {
                        // element has no type or content.
                        // The content of the referenced group is used in this case according to the spec.
                        elementLinkup[nsName] = group;
                        subElemType = group;
                    } else {
                        // Use the defined type (or self if no type)
                        subElemType = resolveNameInNamespace(element['undefined'].type, schema.xmlns, namespaces, schemaTNS);
                    }
                    if (!substitutions[group]) {
                        substitutions[group] = [];
                    }
                    substitutions[group].push({
                        nsName: nsName,
                        name: elemName,
                        type: subElemType
                    });
                }
            } // end for
        }
        if (schema.group) {
            // groups are stored in the groups array, which will be accessed later and processed by inlining
            // the constructs in the group.
            let defGroups = u.makeSureItsAnArray(schema.group);
            let gpLen = defGroups.length;
            for (let j = 0; j < gpLen; j++) {
                let groupType = defGroups[j];
                let nsName = resolveNsName(groupType['undefined'].name, schemaTNS, namespaces);
                groups[nsName] = {
                    group: groupType,
                    tns: schemaTNS,
                    qualified: qualified,
                    qualifiedAttr: qualifiedAttr
                };
            } // end for
        }
        if (schema.attributeGroup) {
            // attribute groups are stored in an array, which will be accessed later and processed by inlining
            // the constructs in the group.
            let defAttrGroups = u.makeSureItsAnArray(schema.attributeGroup);
            for (let j = 0; j < defAttrGroups.length; j++) {
                let attrGroupType = defAttrGroups[j];
                let nsName = resolveNsName(attrGroupType['undefined'].name, schemaTNS, namespaces);
                attrGroups[nsName] = {
                    attrGroup: attrGroupType,
                    tns: schemaTNS,
                    qualified: qualified
                };
            } // end for
        }

        if (schema.attribute) {
            let attrs = u.makeSureItsAnArray(schema.attribute);
            for (let j = 0; j < attrs.length; j++) {
                let attr = attrs[j];
                let attrName = attr['undefined'].name;
                let nsName = resolveNsName(attrName, schemaTNS, namespaces, true);
                originalNames[nsName] = {
                    prefix: prefix,
                    name: u.stripNamespace(attr['undefined'].name)
                };

                // Root attribute is defined:
                // 1) inline
                // 2) with a built-in type, or
                // 3) with a non-built-in type

                if (attr.simpleType) {
                    // 1) Root attribute is defined inline
                    if (!dictEntry[nsName]) {
                        dictEntry[nsName] = {
                            schema: attr.simpleType,
                            isAttribute: true,
                            schemaType: 'simple',
                            tns: schemaTNS,
                            qualified: true,
                            qualifiedAttr: qualifiedAttr,
                            xmlns: schema.xmlns
                        };
                    }
                } else {
                    let isAttrXSD = isXSDType(attr['undefined'].type, namespaces, schema.xmlns);

                    if (isAttrXSD) {
                        // 2) attribute is a primitive type - generate a fake simple type
                        if (!dictEntry[nsName]) {
                            dictEntry[nsName] = {
                                schema: {
                                    undefined: {
                                        name: attrName
                                    },
                                    restriction: {
                                        undefined: {
                                            base: attr['undefined'].type
                                        }
                                    }
                                },
                                schemaType: 'simple',
                                isAttribute: true,
                                tns: schemaTNS,
                                qualified: true,
                                qualifiedAttr: qualifiedAttr,
                                xmlns: schema.xmlns
                            };
                        }
                    } else {
                        // 3) Attribute is defined with a non-bult-in type
                        var attrType = resolveNameInNamespace(attr['undefined'].type, schema.xmlns, namespaces, schemaTNS);
                        if (attrType) {
                            // create an attribute type lookup to be fixed up after we've got all the dictEntry
                            attrLinkup[nsName] = attrType;
                        }
                    }
                }
            } // end for
        } // end attribute
    } // end for

    // elements such as <foo type='bar' >
    // are changed so that the schema object is bar (thus removing the indirection).
    for (let eleName in elementLinkup) {
        let eleType = elementLinkup[eleName];
        if (dictEntry[eleType]) {
            dictEntry[eleName] = u.deepClone(dictEntry[eleType]);

            // Due to the way the schema is processed, the eleType could be
            // an inlined type.  Go ahead continue processing but put out an warning.
            if (!dictEntry[eleName].schema['undefined'] ||
                !dictEntry[eleName].schema['undefined'].name) {
                if (!dictEntry[eleName].schema['undefined']) {
                    dictEntry[eleName].schema['undefined'] = {};
                }
                // Don't issue warning if the elementLinkup is due to a substitionGroup
                if (!substitutions[eleType]) {
                    annotateWithParserMessage(dictEntry[eleName].schema,
                       'Element ' + eleName +
                       ' uses the type attribute to reference element ' + eleType +
                      '.  Processing continues with the referenced element\'s type.');
                }
            }
        }

        if (dictEntry[eleName]) {
            dictEntry[eleName].schema['undefined'].linkup = eleType;
        }
    }

    // patch up named attributes with their types
    for (let aName in attrLinkup) {
        let aType = attrLinkup[aName];
        if (dictEntry[aType]) {
            dictEntry[aName] = u.deepClone(dictEntry[aType]);

            // Due to the way the schema is processed, the aType could be
            // an inlined type.  Go ahead continue processing but put out an warning.
            if (!dictEntry[aName].schema['undefined'] ||
                !dictEntry[aName].schema['undefined'].name) {
                if (!dictEntry[aName].schema['undefined']) {
                    dictEntry[aName].schema['undefined'] = {};
                }
                annotateWithParserMessage(dictEntry[aName].schema,
        'Element ' + aName + ' uses the type attribute to reference attribute ' + aType + '.  Processing continues with the referenced attribute\'s type.');
            }
            dictEntry[aName].isAttribute = true;
            dictEntry[aName].qualified = true;
        }
        if (dictEntry[aName]) {
            dictEntry[aName].schema['undefined'].linkup = aType;
        }
    } // end for

    // created mangled nsNames for hidden types
    for (let nsName in hiddenTypes) {
        const i = nsName.lastIndexOf('_');
        let mangledName = nsName.substring(0, i) + '_type' + nsName.substring(i);
        dictEntry[nsName].hiddenType = mangledName;
        dictEntry[mangledName] = hiddenTypes[nsName];
    }

    // The dictionary
    let dict = {
        dictEntry: dictEntry,
        groups: groups,
        attrGroups: attrGroups,
        elementNS: elementNS,
        originalNames: originalNames,
        substitutions: substitutions,
        subTypes: {},
        exampleNeeded: {},
        pathInfo: [],
        wsdlTNS: wsdlTNS
    };

    // calculate all sub types
    for (let nsName in dict.dictEntry) {
        let dictEntry = dict.dictEntry[nsName];
        if (dictEntry.schema) {
            if (dictEntry.schema.complexContent && dictEntry.schema.complexContent.extension) {
                let extension = dictEntry.schema.complexContent.extension;
                let baseType = bestMatch(extension['undefined'].base, dictEntry, dict, namespaces);
                if (baseType) {
                    if (dict.dictEntry[baseType]) {
                        // store list of sub types of the base type
                        if (!dict.subTypes[baseType]) {
                            dict.subTypes[baseType] = [ nsName ];
                        } else {
                            dict.subTypes[baseType].push(nsName);
                        }
                    }
                }
            } else if (dictEntry.schema.simpleContent && dictEntry.schema.simpleContent.extension) {
                let extension = dictEntry.schema.simpleContent.extension;
                let baseType = resolveNameInNamespace(extension['undefined'].base, dictEntry.xmlns, namespaces);
                if (baseType) {
                    if (dict.dictEntry[baseType]) {
                        // store list of sub types of the base type
                        if (!dict.subTypes[baseType]) {
                            dict.subTypes[baseType] = [ nsName ];
                        } else {
                            dict.subTypes[baseType].push(nsName);
                        }
                    }
                }
            }
        }
    } // end for
    return dict;
}


/**
 * Add predefined NSNames into the dictionary.
 */
function addPredefinedNSNames(dictEntry, detectedWSAddressing) {
    var nsName = 'lang_xml_attr';
    // Add the xml:lang attribute that is defined by the xsd spec
    if (!dictEntry[nsName]) {
        dictEntry[nsName] = {
            schema: {
                undefined: {
                    name: 'lang'
                },
            },
            schemaType: 'predefined',
            qualified: true, // Do this to prevent the xml prefix from being junked
            definition: {
                xml: {
                    name: 'lang',
                    namespace: 'http://www.w3.org/XML/1998/namespace',
                    prefix: 'xml', // Special prefix defined by xsd
                    attribute: true
                },
                type: 'string'
            }
        };
    }

    nsName = 'SubCode__SOAP12';
    if (!dictEntry[nsName]) {

        // SubCode is a self-referencing structure (which is the way schema does linked lists)
        // In practice, it is likely that an actual subcode will only have 1 or 2 links.
        // The gateway (current design) will only proceed one level deep in a self-reference structure.
        // For these reasons, a few layers of the structure are inlined prior to the self-reference.
        dictEntry[nsName] = {
            schema: {
                undefined: {
                    name: 'SubCode'
                },
            },
            schemaType: 'predefined',
            qualified: true,
            definition: {
                xml: {
                    namespace: 'http://www.w3.org/2003/05/soap-envelope',
                    prefix: 'soapenv',
                },
                type: 'object',
                properties: {
                    Value: {
                        type: 'string',
                    },
                    SubCode: {
                        xml: {
                            namespace: 'http://www.w3.org/2003/05/soap-envelope',
                            prefix: 'soapenv',
                        },
                        type: 'object',
                        properties: {
                            Value: {
                                type: 'string',
                            },
                            SubCode: {
                                xml: {
                                    namespace: 'http://www.w3.org/2003/05/soap-envelope',
                                    prefix: 'soapenv',
                                },
                                type: 'object',
                                properties: {
                                    Value: {
                                        type: 'string',
                                    },
                                    SubCode: {
                                        $ref: '#/definitions/SubCode__SOAP12'
                                    }
                                },
                            }
                        },
                    }
                },
                required: [ 'Value' ]
            }
        };
    }

    // This special defintion is only used to carry messages found globally.
    if (!dictEntry[RESERVED_DEF]) {
        dictEntry[RESERVED_DEF] = {
            schema: {
                undefined: {
                    name: 'APIC'
                },
            },
            schemaType: 'predefined',
            qualified: false,
            definition: {
                type: 'string'
            }
        };
    }

    if (detectedWSAddressing) {
        // Add the core WSA elements
        if (!dictEntry['Action__WSA']) {
            dictEntry['Action__WSA'] = {
                schema: {
                    undefined: {
                        name: 'Action'
                    },
                },
                schemaType: 'predefined',
                qualified: true,
                definition: {
                    xml: {
                        namespace: 'http://www.w3.org/2005/08/addressing',
                        prefix: 'wsa',
                        name: 'Action'
                    },
                    type: 'string'
                }
            };
        }
        if (!dictEntry['To__WSA']) {
            dictEntry['To__WSA'] = {
                schema: {
                    undefined: {
                        name: 'To'
                    },
                },
                schemaType: 'predefined',
                qualified: true,
                definition: {
                    xml: {
                        namespace: 'http://www.w3.org/2005/08/addressing',
                        prefix: 'wsa',
                        name: 'To'
                    },
                    type: 'string'
                }
            };
        }
        if (!dictEntry['MessageID__WSA']) {
            dictEntry['MessageID__WSA'] = {
                schema: {
                    undefined: {
                        name: 'MessageID'
                    },
                },
                schemaType: 'predefined',
                qualified: true,
                definition: {
                    xml: {
                        namespace: 'http://www.w3.org/2005/08/addressing',
                        prefix: 'wsa',
                        name: 'MessageID'
                    },
                    type: 'string'
                }
            };
        }
        if (!dictEntry['ReplyTo__WSA']) {
            dictEntry['ReplyTo__WSA'] = {
                schema: {
                    undefined: {
                        name: 'ReplyTo'
                    },
                },
                schemaType: 'predefined',
                qualified: true,
                definition: {
                    xml: {
                        namespace: 'http://www.w3.org/2005/08/addressing',
                        prefix: 'wsa',
                        name: 'ReplyTo'
                    },
                    type: 'object',
                    properties: {
                        Address: {
                            xml: {
                                namespace: 'http://www.w3.org/2005/08/addressing',
                                prefix: 'wsa'
                            },
                            type: 'string'
                        }
                    }
                }
            };
        }

        if (!dictEntry['FaultTo__WSA']) {
            dictEntry['FaultTo__WSA'] = {
                schema: {
                    undefined: {
                        name: 'FaultTo'
                    },
                },
                schemaType: 'predefined',
                qualified: true,
                definition: {
                    xml: {
                        namespace: 'http://www.w3.org/2005/08/addressing',
                        prefix: 'wsa',
                        name: 'FaultTo'
                    },
                    type: 'object',
                    properties: {
                        Address: {
                            xml: {
                                namespace: 'http://www.w3.org/2005/08/addressing',
                                prefix: 'wsa'
                            },
                            type: 'string'
                        }
                    }
                }
            };
        }
    }
}

/**
* Return the RESERVED_DEF dictEntry, which is used for annotating
* problems.
*/
function reserved(dictionary) {
    return dictionary.dictEntry[RESERVED_DEF];
}

/**
 * Add parser error message as documentation in the schema documentation
 * The message will appear in the corresponding swagger description.
 */
function annotateWithParserMessage(target, message) {
    message = '((APIC_MESSAGE: ' + message + '))';
    if (!target) {
        return;
    }
    if (!target.annotation) {
        target.annotation = {};
    }
    if (!target.annotation.documentation) {
        target.annotation.documentation = [];
    }

    target.annotation.documentation = u.makeSureItsAnArray(target.annotation.documentation);

    if (target.annotation.documentation.indexOf(message) < 0) {
        target.annotation.documentation.push(message);
    }
}

/**
 * Resolve the name to an NS Name from name and target namespace.
 * The prefix is chosen from the namespaces map.
 * If the name is for a root attribute (versus a type or element)
 * then isAttribute is set.
 */
function resolveNsName(name, tns, namespaces, isAttribute) {
    var ret = name;
    if (tns) {
        var prefix = u.getPrefixForNamespace(tns, namespaces);
        if (prefix) {
            ret = name + '_' + prefix;
        }
    }

    // Attributes and elements and types can share names
    // Disambiguate attributes (and also improve readability)
    if (isAttribute) {
        ret += '_attr';
    }
    return ret;
}

/**
* Return the list of prefixes defined for the xml schema namespace.
*/
function getXSDPrefixes(namespaces) {
    var ret = [];
    for (var key in namespaces) {
        var namespace = namespaces[key];
        if (namespace == 'http://www.w3.org/2001/XMLSchema') {
            ret.push(key);
        }
    } // end for
    return ret;
}


// returns the fully qualified nsName for the given name matched with the local
// namespace but resolved to the global namespace
function resolveNameInNamespace(name, localNamespaces, globalNamespaces, tns, dict, forAttr) {
    var nsName = name;
    if (name) {
        var index = name.indexOf(':');
        if (index != -1) {
            var rawPrefix = name.substring(0, index);
            var rawName = name.substr(index + 1);
            var prefix;
            var namespace;
            // the given name should always be mapped through the local namespace first, if supplied
            if (localNamespaces && localNamespaces[rawPrefix]) {
                namespace = localNamespaces[rawPrefix];
                prefix = u.getPrefixForNamespace(namespace, globalNamespaces);
                nsName = rawName + '_' + prefix;
            } else if (globalNamespaces && globalNamespaces[rawPrefix]) {
                namespace = globalNamespaces[rawPrefix];
                prefix = u.getPrefixForNamespace(namespace, globalNamespaces);
                nsName = rawName + '_' + prefix;
            } else {
                nsName = rawName + '_' + rawPrefix;
            }
            if (forAttr) {
                nsName += '_attr';
            }
        } else {
            // If there is no prefix, then this is a case where the default namespace is used.
            // Get the all of the prefixes in the preferred order, then search for a match
            if (dict) {
                var prefixes = preferedOrderPrefixes(localNamespaces, globalNamespaces, tns);
                let prefixesLen = prefixes.length;
                for (var i = 0; i < prefixesLen; i++) {
                    var tryName = name + '_' + prefixes[i];
                    if (forAttr) {
                        tryName += '_attr';
                    }
                    if (dict.dictEntry[tryName]) {
                        nsName = tryName; // Found a match
                        break;
                    }
                }
            } else {
                if (tns) {
                    nsName = resolveNsName(name, tns, globalNamespaces);
                }
                if (forAttr) {
                    nsName += '_attr';
                }
            }
        }
    }
    return nsName;
}

/**
* Return true if built-in xsd type
*/
function isXSDType(type, namespaces, namespaces2) {
    var ret = false;
    var index, prefix;
    var xsdPrefixes = getXSDPrefixes(namespaces);
    if (xsdPrefixes.length > 0 && type) {
        index = type.indexOf(':');
        if (index != -1) {
            prefix = type.substring(0, index);
            if (xsdPrefixes.indexOf(prefix) != -1) {
                ret = true;
            }
        } else if (getXSDMapping(type)) {
            ret = true;
        }
    }
    if (namespaces2 && !ret) {
        xsdPrefixes = getXSDPrefixes(namespaces2);
        if (xsdPrefixes.length > 0 && type) {
            index = type.indexOf(':');
            if (index != -1) {
                prefix = type.substring(0, index);
                if (xsdPrefixes.indexOf(prefix) != -1) {
                    ret = true;
                }
            }
        }
    }
    return ret;
}

/**
* Return true if xsd:isAnyType
*/
function isXSDAnyType(type, namespaces, namespaces2) {
    if (isXSDType(type, namespaces, namespaces2)) {
        var shortName = type;
        var index = type.indexOf(':');
        if (index != -1) {
            shortName = type.substring(index + 1);
        }
        return (shortName === 'anyType');
    }
    return false;
}

/**
* Returns the best match NSName
*/
function bestMatch(name, schema, dict, namespaces, forAttr, forRef) {
    var ret = name;
    if (name && schema && dict && dict.dictEntry) {
        let nsName = resolveNameInNamespace(name, schema.xmlns, namespaces, schema.tns, dict, forAttr);
        if (!dict.dictEntry[nsName]) {
            // For historical reasons the namespace is stripped for context specific fallback processing.
            nsName = u.stripNamespace(name);

            // Failed to find this name in the all of the schema that was processed.
            // If not a built-in name then annotate the swagger.
            if (dict.dictEntry[RESERVED_DEF]) {
                if (!getXSDMapping(nsName)) {
                    if (!isXSDType(name, namespaces, schema.xmlns)) {
                        annotateWithParserMessage(dict.dictEntry[RESERVED_DEF].schema, 'Could not resolve ' + name);
                    } else if (nsName && nsName.length > 0) {
                        annotateWithParserMessage(dict.dictEntry[RESERVED_DEF].schema, 'Mapping xsd type ' + name + ' to string.');
                    }
                }
            }
        } else {
            // In schema, an element and type may have the same name.
            // If the element references the type, then the content is the same and the same entry is used in
            // the dictionary (allSchema.dictEntry).  But if the content is different, then the dictionary entry
            // is the element and its hiddenType field is the dictionary for the type.
            // This second scenario is rare, but in such cases we differentiate which dictionary entry is needed
            // by looking at the context 'forRef' used for the resolution.
            if (!forRef && dict.dictEntry[nsName].hiddenType) {
                nsName = dict.dictEntry[nsName].hiddenType;
            }
        }
        if (nsName) {
            ret = nsName;
        }
    }
    return ret;
}


/**
 * Prefered Order of prefixes when sorting for a defaultNamespace
 */
function preferedOrderPrefixes(localNamespaces, globalNamespaces, tns) {
    var prefixes = [];
    var prefix;
    // First add the special ns* prefixes that are added by the npm soap Utility
    var i = 1;
    prefix = 'ns' + i;
    while ((globalNamespaces && globalNamespaces[prefix]) || (localNamespaces && localNamespaces[prefix])) {
        prefixes.push(prefix);
        i++;
        prefix = 'ns' + i;
    }
    // Now try tns
    if (tns) {
        prefix = u.getPrefixForNamespace(tns, localNamespaces);
        if (prefix) {
            prefixes.push(prefix);
        }
        prefix = u.getPrefixForNamespace(tns, globalNamespaces);
        if (prefix) {
            prefixes.push(prefix);
        }
    }
    // Now add the local prefixes
    for (prefix in localNamespaces) {
        prefixes.push(prefix);
    }

    // Now add the global prefixes
    for (prefix in globalNamespaces) {
        prefixes.push(prefix);
    }
    return prefixes;
}

/**
* Return the xso mapping for built-xsd names
*/
function getXSDMapping(shortName) {
    var XSD_MAPPING = {
        int: {
            type: 'integer',
            format: 'int32'
        },
        unsignedInt: {
            type: 'integer',
            format: 'int64',
            minimum: 0,
            maximum: 4294967295
        },
        unsignedShort: {
            type: 'integer',
            format: 'int32',
            minimum: 0,
            maximum: 65535
        },
        unsignedByte: {
            type: 'integer',
            format: 'int32',
            minimum: 0,
            maximum: 255
        },
        long: {
            type: 'integer',
            format: 'int64'
        },
        unsignedLong: {
            type: 'number',
            minimum: 0
        },
        short: {
            type: 'integer',
            format: 'int32',
            minimum: -32768,
            maximum: 32767
        },
        integer: {
            type: 'number'
        },
        decimal: {
            type: 'number'
        },
        negativeInteger: {
            type: 'number',
            maximum: -1
        },
        nonNegativeInteger: {
            type: 'number',
            minimum: 0
        },
        nonPositiveInteger: {
            type: 'number',
            maximum: 0
        },
        positiveInteger: {
            type: 'number',
            minimum: 1
        },
        float: {
            type: 'number',
            format: 'float'
        },
        double: {
            type: 'number',
            format: 'double'
        },
        string: {
            type: 'string'
        },
        byte: {
            type: 'string',
            format: 'byte'
        },
        binary: {
            type: 'string',
            format: 'binary'
        },
        boolean: {
            type: 'boolean'
        },
        anyType: {
            'x-anyType': true, // Note that no type is provided
        },
        date: {
            type: 'string',
            format: 'date'
        },
        dateTime: {
            type: 'string',
            format: 'date-time'
        },
        anyURI: {
            type: 'string',
            description: 'anyURI'
        },
        anySimpleType: {
            type: 'string'
        },
        NOTATION: {
            type: 'string'
        },
        QName: {
            type: 'string'
        },
        base64Binary: {
            type: 'string',
            format: 'binary'
        },
        hexBinary: {
            type: 'string',
            description: 'base64Binary'
        }, // Don't know what to do for format
        time: {
            type: 'string'
        },
        duration: {
            type: 'string'
        },
        gYearMonth: {
            type: 'string'
        },
        gYear: {
            type: 'string'
        },
        gDay: {
            type: 'string'
        },
        gMonth: {
            type: 'string'
        },
        gMonthDay: {
            type: 'string'
        },
        NCName: {
            type: 'string'
        },
        ID: {
            type: 'string'
        },
        normalizedString: {
            type: 'string'
        },
        token: {
            type: 'string'
        },
        language: {
            type: 'string'
        },
        NMToken: {
            type: 'string'
        },
        Name: {
            type: 'string'
        },
        IDREF: {
            type: 'string'
        },
        ENTITY: {
            type: 'string'
        }
    };

    return XSD_MAPPING[shortName];
}

/**
 * Generated a NS Name from the raw reference ("prefix:name")
 * If the raw reference is to an attribute (versus a type or element)
 * then isAttribute is set.
 */
function getNsName(rawType, isAttribute) {
    var ret = rawType;
    if (rawType) {
        var index = rawType.indexOf(':');
        if (index != -1) {
            var rawPrefix = rawType.substring(0, index);
            var rawName = rawType.substr(index + 1);
            ret = rawName + '_' + rawPrefix;
        }
    }
    if (isAttribute) {
        ret += '_attr';
    }
    return ret;
}

// checks the given name and generates a new one if it conflicts with an existing schema
function makeUniqueNSName(name, dict) {
    var ret = name;
    if (name && dict && dict.dictEntry && dict.dictEntry[name]) {
        var index = 1;
        ret = name + '_' + index;
        while (dict.dictEntry[ret]) {
            index += 1;
            ret = name + '_' + index;
        } // end while
    }
    return ret;
}

exports.annotateWithParserMessage = annotateWithParserMessage;
exports.buildDictionary = buildDictionary;
exports.getXSDMapping = getXSDMapping;
exports.getNsName = getNsName;
exports.isXSDType = isXSDType;
exports.makeUniqueNSName = makeUniqueNSName;
exports.resolveNameInNamespace = resolveNameInNamespace;
exports.bestMatch = bestMatch;
exports.RESERVED_DEF = u.RESERVED_DEF;
