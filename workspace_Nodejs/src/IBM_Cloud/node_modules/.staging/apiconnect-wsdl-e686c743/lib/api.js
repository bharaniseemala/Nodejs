/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parse = require('../lib/parse.js');
const generate = require('../lib/generateSwagger.js');
const openapiv3 = require('../lib/openApiV3.js');
const validate = require('../lib/validate.js');
const extraXSD = require('../lib/extraXSD.js');

var q = require('q');

/**
 * Create an openapi from wsdl
 * @param {Buffer or String file location or String url} wsdl or zip content
 * @param {String} serviceName name of the wsdl service
 * @param {String} wsdlId id to use in the generated swagger.  Often this is the filename
 * @param options
 *     type: 'wsdl' (default) or 'wsdl-to-rest'
 *     openapiVersion: '2.0' (default) or '3.0'
 *     allowExtraFiles: false (default) or true
 *     defaults: object to merge into openapi after generation.  Same shape as openapi
 *     auth: auth object if wsdl is protected url
 *     badgerfishDefs: true (default) or false.  Json definitions in badgerfish form
 *     mapOptions: setting to use for autogenerated assembly map. The default is no map.options
 *         mapOptions.includeEmptyXMLElements
 *         mapOptions.namespaceInheritance
 *         mapOptions.inlineNamespaces
 *     mapSOAPFaults: true (default) or false.  Catch block for SOAPFaults
 * @return {
 *              openapi: <openapi>
 *              statistics: { various stats}
 *              messages: [ {message: <info message>}* ]
 *         }
 */
function createOpenApi(wsdl, serviceName, wsdlId, options) {
    options = options || {};
    options.type = options.type || 'wsdl';
    options.openapiVersion = options.openapiVersion || '2.0';
    options.allowExtraFiles = (typeof options.allowExtraFiles === 'undefined') ? false : options.allowExtraFiles;
    options.badgerfishDefs = (typeof options.badgerfishDefs === 'undefined') ? true : options.badgerfishDefs;
    options.mapSOAPFaults = (typeof options.mapSOAPFaults === 'undefined') ? true : options.mapSOAPFaults;

    let def = q.defer();
    try {
        if (options.openapiVersion !== '2.0'  && options.openapiVersion != '3.0') {
            def.resolve(u.makeValidationErr('expected openapiVersion of 2.0 or 3.0, but found:' + options.openapiVersion));
            return def.promise;
        }
        if (options.type !== 'wsdl' && options.type != 'wsdl-to-rest') {
            def.resolve(u.makeValidationErr('expected type of wsdl or wsdl-to-rest, but found:' + options.types));
            return def.promise;
        }

        // Parse the wsdl
        parse.getJsonForWSDL(wsdl, options.auth, options).then(function(allWSDLs) {
            try {
                // Locate the wsld entry for the indicated service
                let wsdlEntry = parse.findWSDLForServiceName(allWSDLs, serviceName, null);

                // Create a 2.0 wsdl proxy or wsdl to rest open api
                let openapi = (options.type === 'wsdl-to-rest') ?
                    generate.generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, options) :
                    generate.generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, options);

                let convertDef = q.defer();
                // Convert to 3.0 if necessary
                if (options.openapiVersion === '2.0') {
                    convertDef.resolve(openapi);
                } else {
                    openapiv3.getOpenApiV3(openapi).then(function(openapi) {
                        convertDef.resolve(openapi);
                    }, function(err) {
                        convertDef.reject(err);
                    });
                }
                // Add statistics and warning messages
                convertDef.promise.then(function(openapi) {
                    try {
                        let result = validate.inspectOpenApi({ openapi: openapi });
                        def.resolve(result);
                    } catch (err) {
                        def.reject(u.convertToValidationErr(err));
                    }
                }, function(err) {
                    def.reject(u.convertToValidationErr(err));
                });
            } catch (e) {
                def.reject(u.convertToValidationErr(e));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addTargetOpenApi
* @param openApi - existing openApi
* @param wsdl - Buffer containing the wsdl/zip or location of the wsdl/zip
* @param wsdlServiceName - Service
* @return promise openApi
*/
function addTargetOpenApi(openapi, wsdl, wsdlServiceName) {
    let def = q.defer();
    try {
        // Create a target openapi of the same version as the parent
        let tgtOptions = {
            type: 'wsdl',
            openapiVersion: (openapi.openapi) ? '3.0' : '2.0'
        };
        createOpenApi(wsdl, wsdlServiceName, wsdlServiceName, tgtOptions).then(function(result) {
            try {
                // Update the references to point at the target definitions/schemas
                let tgtOpenApi = updateRefs(result.openapi, wsdlServiceName);

                openapi['x-ibm-configuration'].targets = openapi['x-ibm-configuration'].targets || {};
                openapi['x-ibm-configuration'].targets[wsdlServiceName] = tgtOpenApi;
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

/**
* addXSDToTargetOpenApi
* @param openApi - existing openApi
* @param xsd - Buffer containing the xsd or location of the xsd
* @param wsdlServiceName - Service
* @return promise openApi
*/
function addXSDToTargetOpenApi(openapi, xsd, wsdlServiceName) {
    let def = q.defer();
    try {
        extraXSD.getDefinitionsForXSD(xsd).then(function(definitions) {
            try {
                // Find the definition section of the target schema
                let tgt = openapi['x-ibm-configuration'].targets[wsdlServiceName];
                if (openapi.openapi) {
                    tgt = tgt.components.schemas;
                } else {
                    tgt = tgt.definitions;
                }
                // Add the new definitions
                for (let definition in definitions) {
                    tgt[definition] = u.deepClone(definitions[definition]);
                }
                def.resolve(openapi);
            } catch (err) {
                def.reject(u.convertToValidationErr(err));
            }
        }, function(err) {
            def.reject(u.convertToValidationErr(err));
        });
    } catch (err) {
        def.reject(u.convertToValidationErr(err));
    }
    return def.promise;
}

function updateRefs(json, serviceName) {
    let jsonString = JSON.stringify(json);
    let src = '#/';
    let tgt = '#/x-ibm-configuration/targets/' + serviceName + '/';
    jsonString = jsonString.replace(new RegExp(src, 'g'), tgt);
    return JSON.parse(jsonString);
}

/**
* Validates wsdl and rejects with error containing messages.
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise of serviceData
*/
function validateWSDL(locationOrContent, options) {
    options = options || {};
    var def = q.defer();
    var valErr = new Error('Validation Error');
    const opts = {
        validate: true,
        selfContained: true,  // All files must be included in the content..no remote files or local file system files
        allowExtraFiles: options.allowExtraFiles || false  // Only allow xsd and wsdl files in the zip
    };
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                // Extra validation of the wsdl defintion
                let errs = [];
                for (let i = 0; i < allWsdls.length; i++) {
                    errs = errs.concat(parse.sanityCheckDefinition(allWsdls[i].json.definitions));
                }
                for (let i = 0; i < errs.length; i++) {
                    u.addValidationErr(valErr, errs[i]);
                }

                // Get the list of services, ports, and bindings
                let serviceData = parse.getWSDLServices(allWsdls);

                // Validate the serviceData
                if (!serviceData ||
                    !serviceData.bindings || serviceData.bindings.length == 0 ||
                    !serviceData.portTypes || serviceData.bindings.portTypes == 0) {
                    u.addValidationErr(valErr, 'A wsdl definition was not found.');
                } else if (!serviceData || !serviceData.services || serviceData.services.length == 0) {
                    u.addValidationErr(valErr, 'No wsdl services were found.');
                } else {
                    for (let service of serviceData.services) {
                        if (!service.operations || service.operations.length == 0) {
                            u.addValidationErr(valErr, 'The wsdl service ' + service.service + ' does not contain a port.');
                        }
                    }
                }
                if (valErr.messages && valErr.messages.length > 0) {
                    def.reject(valErr);
                } else {
                    def.resolve(serviceData);
                }
            } catch (e) {
                u.addValidationErr(valErr, e);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* Validates xsd and rejects with error containing messages.
* @param locationOrContent location of XSD or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise
*/
function validateXSD(locationOrContent, options) {
    options = options || {};
    var def = q.defer();
    var valErr = new Error('Validation Error');
    const opts = {
        validate: true,
        selfContained: true,  // All files must be included in the content..no remote files or local file system files
        allowExtraFiles: options.allowExtraFiles || false  // Only allow xsd and wsdl files in the zip
    };
    try {
        // Parse the wsdl
        parse.getJsonForWSDL(locationOrContent, options.auth, opts).then(function(allWsdls) {
            try {
                parse.getWSDLServices(allWsdls);
                def.resolve();
            } catch (e) {
                u.addValidationErr(valErr, e);
                def.reject(valErr);
            }
        }, function(e) {
            u.addValidationErr(valErr, e);
            def.reject(valErr);
        });
    } catch (e) {
        u.addValidationErr(valErr, e);
        def.reject(valErr);
    }
    return def.promise;
}

/**
* @param locationOrContent location of WSDL or Buffer
* If a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param options auth and other options.
* @returns promise of serviceData
*/
function introspectWSDL(locationOrContent, options) {
    return validateWSDL(locationOrContent, options);
}


exports.addTargetOpenApi = addTargetOpenApi;
exports.addXSDToTargetOpenApi = addXSDToTargetOpenApi;
exports.createOpenApi = createOpenApi;
exports.introspectWSDL = introspectWSDL;
exports.validateWSDL = validateWSDL;
exports.validateXSD = validateXSD;
