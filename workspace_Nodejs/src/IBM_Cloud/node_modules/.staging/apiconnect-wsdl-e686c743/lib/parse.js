/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parseUtils = require('../lib/parseUtils.js');
const postParse = require('../lib/postParse.js');
const flattener = require('../lib/flatten.js');

var q = require('q');
var yauzl = require('yauzl');


/**
* Main entry point for accessing the files and returning the
* parsed content (allWSDLs).
* @param locations (usually 1) of wsdl/zip files/urls
* If array item is a String, algorithm assumes a location on file system or url.
* If that fails, the algorithm attempts to create a base64 or binary buffer from the String
* @param auths (for access if locations is protected url)
* @return allWSDLs, which is a array of wsdlEntry object representing
* the parsed information.
*/
function getJsonForWSDL(locations, auths, options) {
    var def = q.defer();
    var files = [];
    var promiseList = [];
    var flatten = false;
    if (options) {
        flatten = options.flatten;
    } else {
        // Allow extra files in zip files...this is the legacy behavior
        options = {
            allowExtraFiles: true
        };
    }

    // Get JsonForWSDL for each file
    locations = u.makeSureItsAnArray(locations);
    auths = u.makeSureItsAnArray(auths, true);

    for (var i = 0; i < locations.length; i++) {
        promiseList.push(_getJsonForWSDL(locations[i], auths[i], options));
    }

    // Once all of the files are done, combine together
    Promise.all(promiseList).then(values => {
        // Combine the files into one array
        for (i = 0; i < values.length; i++) {
            files = files.concat(values[i]);
        }

        // check for internal errors
        for (i = 0; i < files.length; i++) {
            let file = files[i];
            if (file.doc && file.doc.internalError) {
                // If an internal is caught during parsing, throw it now.
                if (file.doc.internalError.message) {
                    file.doc.internalError.message = 'The wsdl file is incorrect: ' + file.doc.internalError.message;
                }
                def.reject(file.doc.internalError);
            }
        }

        // Now post process the files and return the allWSDLs array
        var checkDef = postParse.checkForWSDLImports(files, auths[0], options);
        checkDef.then(function(allWSDLs) {

            // Flattening takes extra resources, so you need to request it.
            if (flatten) {
                flattener.flatten(files, allWSDLs);
            }
            def.resolve(allWSDLs);
        }, function(e) {
            def.reject(e);
        });
    }).catch(reason => {
        def.reject(reason);
    });
    return def.promise;
}

/**
* Do some simple checking of the wsdl definition object and return an array of the problems found
*/
function sanityCheckDefinition(definitions) {
    let errs = [];
    // Make sure each portType.operation references a defined message
    let portTypes = u.makeSureItsAnArray(definitions.portType);
    let messages = u.makeSureItsAnArray(definitions.message);
    let bindings = u.makeSureItsAnArray(definitions.binding);
    let services = u.makeSureItsAnArray(definitions.service);


    // Make sure each operation references a message
    for (let i = 0; i < portTypes.length; i++) {
        let portType = portTypes[i];
        let operations = u.makeSureItsAnArray(portType.operation);
        for (let j = 0; j < operations.length; j++) {
            let operation = operations[j];
            let opName = operation['undefined'].name;
            let children = [ 'input', 'output', 'fault' ];
            for (let c = 0; c < children.length; c++) {
                let key = children[c];
                if (operation[key] && operation[key]['undefined'] && operation[key]['undefined'].message) {
                    let message = u.stripNamespace(operation[key]['undefined'].message);
                    let found = false;
                    for (let m = 0; m < messages.length  && !found; m++) {
                        if (messages[m]['undefined'] && messages[m]['undefined']) {
                            if (messages[m]['undefined'].name === message) {
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        errs.push('Could not find wsdl message "' + message + '" referenced in wsdl operation "' + opName + '".');
                    }
                }
            }
        }
    }
    // Make sure every binding operation has a matching portType operation
    for (let i = 0; i < bindings.length; i++) {
        let binding = bindings[i];
        let bindingName = binding['undefined'].name;
        let bOperations = u.makeSureItsAnArray(binding.operation);
        let portTypeName = u.stripNamespace(binding['undefined'].type);
        for (let j = 0; j < portTypes.length; j++) {
            let portType = portTypes[j];
            if (portType['undefined'].name === portTypeName) {
                let pOperations = u.makeSureItsAnArray(portType.operation);
                if (pOperations.length !== bOperations.length) {
                    errs.push('The number of operations in binding "' + bindingName +
                     '" does not match the number of operations in its portType "' + portTypeName + '".');
                }
                for (let k = 0; k < bOperations.length; k++) {
                    let bOpName = bOperations[k]['undefined'].name;
                    let found = false;
                    for (let l = 0; l < pOperations.length && !found; l++) {
                        let pOpName = pOperations[l]['undefined'].name;
                        if (pOpName === bOpName) {
                            found = true;
                        }
                    }
                    if (!found) {
                        errs.push('The operation "' + bOpName + '" in binding "' + bindingName +
                         '" does not match any operations in its portType "' + portTypeName + '".');
                    }
                }
            }
        }
    }
    // Make sure the services have bindings
    for (let i = 0; i < services.length; i++) {
        let service = services[i];
        let serviceName = service['undefined'].name;
        let ports = u.makeSureItsAnArray(service.port);
        for (let j = 0; j < ports.length; j++) {
            let port = ports[j];
            let portName = port['undefined'].name;
            let bindingName = u.stripNamespace(port['undefined'].binding);
            let found = false;
            for (let k = 0; k < bindings.length && !found; k++) {
                let binding = bindings[k];
                if (binding['undefined'].name === bindingName) {
                    found = true;
                }
            }
            if (!found) {
                errs.push('The binding "' + bindingName + '" referenced by service "' + serviceName +
                 '" cannot be found .');
            }
        }
    }
    return errs;
}


/**
* Get the services from allWSDLs.  Primarily used by the UI to display the services found
* in the parsed information (allWSDLs) so that the user can choose which service to generate.
* @param allWSDLs (from getJsonForWSDL)
* @returns data object that contains the names of the services, portTypes, bindings, serviceOperations
*/
function getWSDLServices(allWSDLs) {
    var data = {
        portTypes: {},
        bindings: {},
        services: []
    };
    try {
        var wLen = allWSDLs.length;
        var operations, operation, ops;
        var serviceMap = {};
        for (var x = 0; x < wLen; x++) {
            var wsdlJson = allWSDLs[x].json;
            var portTypes = u.makeSureItsAnArray(wsdlJson.definitions.portType);
            var typeLen = portTypes.length;
            for (var i = 0; i < typeLen; i++) {
                var portType = portTypes[i];
                operations = u.makeSureItsAnArray(portType.operation);
                ops = [];
                var len = operations.length;
                for (var p = 0; p < len; p++) {
                    operation = operations[p];
                    ops.push({
                        name: operation['undefined'].name,
                        description: u.cleanupDocumentation(operation.documentation)
                    });
                } // end for
                data.portTypes[portType['undefined'].name] = ops;
            } // end for
            var bindings = u.makeSureItsAnArray(wsdlJson.definitions.binding);
            var binLen = bindings.length;
            for (var j = 0; j < binLen; j++) {
                var binding = bindings[j];
                var bindingType = binding['undefined'].type;
                bindingType = u.stripNamespace(bindingType);
                operations = u.makeSureItsAnArray(binding.operation);
                ops = [];
                var operLen = operations.length;
                for (var n = 0; n < operLen; n++) {
                    operation = operations[n];
                    ops.push(operation['undefined'].name);
                } // end for
                var bind = {
                    type: bindingType,
                    operations: ops
                };
                data.bindings[binding['undefined'].name] = bind;
            } // end for
            var services = u.makeSureItsAnArray(wsdlJson.definitions.service);
            var servLen = services.length;
            for (var k = 0; k < servLen; k++) {
                var service = services[k];
                var bindingLookup = {};
                var ports = u.makeSureItsAnArray(service.port);
                var portLen = ports.length;
                // If the service has multiple ports, the API is built from
                // the first port and the other ports are ignored.
                if (portLen > 1) {
                    portLen = 1;
                }
                for (var l = 0; l < portLen; l++) {
                    var port = ports[l];
                    var bindingName = u.stripNamespace(port['undefined'].binding);
                    bindingLookup[bindingName] = true;
                } // end for
                var endpoint = '';
                if (portLen > 0) {
                    if (ports[0].address &&
              ports[0].address['undefined']) {
                        endpoint = ports[0].address['undefined'].location;
                    }
                }
                var portTypeLookup = {};
                for (var bindName in bindingLookup) {
                    var b = data.bindings[bindName];
                    if (b) {
                        portTypeLookup[b.type] = true;
                    }
                } // end for
                var serviceOperations = [];
                for (var pt in portTypeLookup) {
                    var opers = data.portTypes[pt];
                    if (opers) {
                        serviceOperations = serviceOperations.concat(opers);
                    }
                } // end for
                var serv = {
                    service: service['undefined'].name,
                    filename: allWSDLs[x].filename,
                    operations: []
                };
                if (service.documentation) {
                    serv.description = u.cleanupDocumentation(service.documentation);
                }
                var opLen = serviceOperations.length;
                for (var m = 0; m < opLen; m++) {
                    var opName = serviceOperations[m].name;
                    var opObj = {
                        operation: opName
                    };
                    if (serviceOperations[m].description) {
                        opObj.description = serviceOperations[m].description;
                    }
                    serv.operations.push(opObj);
                } // end for

                // Add service if there are actual serviceChildren
                // and the service in this first time that the service for this
                // file or endpoint is encountered.
                // (The endpoint is checked because a service will occur multiple times in
                // allWSDLs for circular wsdl imports, so we use the endpoints to ensure that only
                // one of these is used).
                if (allWSDLs[x].serviceChildren && allWSDLs[x].serviceChildren != {}) {
                    if (!serviceMap[serv.service]) {
                        serviceMap[serv.service] = [];
                    }
                    var found = false;
                    for (var ss = 0; !found && ss < serviceMap[serv.service].length; ss++) {
                        if (serviceMap[serv.service][ss].fullName === allWSDLs[x].fullName ||
                            serviceMap[serv.service][ss].endpoint === endpoint) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        serviceMap[serv.service].push(
              {
                  serv: serv,
                  fullName: allWSDLs[x].fullName,
                  endpoint: endpoint
              });
                        data.services.push(serv);
                    }
                }
            } // end for
        } // end for

        // Find duplicates and disambiguate the names
        // <serviceName>-from-<slugifyfullname>
        for (var s in serviceMap) {
            if (serviceMap[s].length > 1) {
                for (var z = 0; z < serviceMap[s].length; z++) {
                    serviceMap[s][z].serv.service += '-from-' + u.slugifyName(serviceMap[s][z].fullName);
                }
            }
        }
        return u.checkAndFix(data);
    } catch (error) {
        console.log('Error parsing WSDL');
        console.log(error);
        return u.checkAndFix(data);
    }
}

/**
* @param allWSDLs (from getJsonForWSDL)
* @param serviceName (wsdl service name)
* @param servieFileName (used as a differentiator if multiple services with the same name)
* @returns WSDLEntry object for the indicated service.
*/
function findWSDLForServiceName(allWSDLs, serviceName, serviceFilename) {
    var ret = null;
    var len = allWSDLs.length;
    // If multiple services of the same name were detected,
    // then the serviceName was changed to disambiguate the services
    // <serviceName>-from-<slugifiedpath>
    var slugifyServiceFullName;
    var mangleIndex = serviceName.indexOf('-from-');
    if (mangleIndex > 0) {
        slugifyServiceFullName = serviceName.substring(mangleIndex + 6);
        serviceName = serviceName.substring(0, mangleIndex);
        serviceFilename = null;
    }
    for (var i = 0; i < len; i++) {
        var wsdlEntry = allWSDLs[i];
        if (wsdlEntry.serviceChildren && wsdlEntry.serviceChildren[serviceName]) {
            if (slugifyServiceFullName && wsdlEntry.fullName) {
                if (slugifyServiceFullName == u.slugifyName(wsdlEntry.fullName)) {
                    ret = wsdlEntry;
                    break;
                }
            } else if (serviceFilename && wsdlEntry.filename) {
                if (serviceFilename == wsdlEntry.filename) {
                    ret = wsdlEntry;
                    break;
                }
            } else {
                ret = wsdlEntry;
                break;
            }
        }
    } // end for
    return ret;
}

/**
 * Get allWSDLS for a single wsdl file (or zip)
 */
function _getJsonForWSDL(filename, auth, options) {
    let opts = options || {};
    var totalProcessed = 0;
    var reject = false;  // Necessary to help halt distributed process of zip entries
    var def = q.defer();
    var files = [];
    try {
        // Get the rawContent of the files
        var fetchDef = parseUtils.getFileContent(filename, filename, auth);
        fetchDef.then(function(rawContent) {
            var left = rawContent.toString('utf8', 0, 4).substr(0, 4);
            if (left == 'PK\u0003\u0004') {
                // it's a ZIP file - go fetch all the content
                let rawContentObjectName = u.getObjectName(rawContent);
                rawContent = parseUtils.toBuffer(rawContent);
                yauzl.fromBuffer(rawContent, {
                    lazyEntries: true
                }, function(err, zipFile) {
                    if (err) {
                        reject = true;
                        let detail = 'The content may have been uploaded with a wrong encoding (i.e. utf8). ' +
                          'Here are the first 50 base64 characters of the content:' + rawContent.toString('base64', 0, 50);
                        def.reject(new Error('The zip file format is incorrect: (' + err +
                          ') (Internal: Found while processing ' + rawContentObjectName + ') ' + detail));
                    } else if (!reject) {
                        zipFile.readEntry();
                        zipFile.on('error', function(err) {
                            reject = true;
                            let detail = 'The content may have been uploaded with a wrong encoding (i.e. utf8). ' +
                              'Here are the first 50 base64 characters of the content:' + rawContent.toString('base64', 0, 50);
                            def.reject(new Error('The zip file format is incorrect: (' + err +
                              ') (Internal: Found while processing ' + rawContentObjectName + ') ' + detail));
                        });
                        zipFile.on('entry', function(entry) {
                            if (/\/$/.test(entry.fileName) || (/__MACOSX/).test(entry.fileName)) {
                                // ignore directories and MAC archives
                                zipFile.readEntry();
                            } else {
                                var strings = [];
                                zipFile.openReadStream(entry, function(err, readStream) {
                                    if (err) {
                                        reject = true;
                                        def.reject(err);
                                    } else {
                                        readStream.on('data', function(chunk) {
                                            strings.push(chunk);
                                        });
                                        readStream.on('end', function() {
                                            var nameLen = entry.fileName.length;
                                            let isXMLSuffix = entry.fileName.indexOf('.xml', nameLen - 4) != -1;
                                            let isXSDSuffix = entry.fileName.indexOf('.xsd', nameLen - 4) != -1;
                                            let isWSDLSuffix = entry.fileName.indexOf('.wsdl', nameLen - 5) != -1;

                                            // Throw an error if only allowing xsd and wsdl files
                                            // and this is an extra file
                                            if (!opts.allowExtraFiles && !isWSDLSuffix && !isXSDSuffix) {
                                                def.reject(parseUtils.cleanupError(
                                                  new Error('Only .xsd and .wsdl files are allowed in the zip.  Found: ' + entry.fileName)));
                                            }
                                            // An .xml file may contain xsd or it may contain random
                                            // xml information.  Try to read .xml files but don't report
                                            // errors.
                                            if (isWSDLSuffix || isXSDSuffix || isXMLSuffix) {
                                                // only discover WSDLs and XSDs
                                                var shortName = entry.fileName;
                                                var index = shortName.lastIndexOf('/');
                                                if (index != -1) {
                                                    shortName = shortName.substr(index + 1);
                                                }
                                                var file = {
                                                    filename: shortName,
                                                    fullName: entry.fileName,
                                                    type: 'wsdl', // temp for now determined later when we actually parse it
                                                    content: '',
                                                    context: 'zip'
                                                };
                                                file.content = Buffer.concat(strings);
                                                var encoding = parseUtils.determineEncoding(file.content, file.fullName);
                                                file.content = parseUtils.decode(file.content, encoding);
                                                totalProcessed += file.content.length;
                                                try {
                                                    // If the customer proviced a very, very large zip file containing
                                                    // many large xsds that are unreferenced, the zip file processing
                                                    // will run out of memory and the designer will hang.
                                                    // An error message is better than a hang.
                                                    // An alternative is to do mult-passes through the zip collecting
                                                    // only the schema that is needed, but that is slow and error prone.
                                                    if (totalProcessed > 64000000) {
                                                        throw new Error('The zip file contains too many large xsd/wsdl files. ' +
                                                           'Please remove unnecessary xsd/wsdl files and try again.');
                                                    }
                                                    try {
                                                        parseUtils.contentToXMLorWSDL(file);
                                                    } catch (e) {
                                                        // If the file is not a wsdl, then save the error
                                                        // and rethrow later only if it is is included or imported
                                                        if (isWSDLSuffix) {
                                                            throw e;
                                                        } else {
                                                            file.error = e;
                                                            file.type = 'xsd';
                                                        }
                                                    }
                                                    let valid = false;
                                                    if (file.error) {
                                                        files.push(file);
                                                    } else if (file.json.definitions) {
                                                        var wsdlGood = parseUtils.validateWSDLJson(file.json, file.filename);
                                                        if (wsdlGood.valid) {
                                                            files.push(file);
                                                            file.type = 'wsdl';
                                                            var namespaces = file.doc.definitions.xmlns;
                                                            file.namespaces = namespaces;
                                                            valid = true;
                                                        } else {
                                                            throw new Error(wsdlGood.reason);
                                                        }
                                                    } else if (file.json.schema) {
                                                        files.push(file);
                                                        file.type = 'xsd';
                                                        file.namespaces = {};
                                                        valid = true;
                                                    } else {
                                                        let e = new Error('Failed to parse WSDL or XSD: ' + file.filename);
                                                        if (isWSDLSuffix) {
                                                            throw e;
                                                        } else {
                                                            file.error = e;
                                                            file.type = 'xsd';
                                                            files.push(file);
                                                        }
                                                    }
                                                    // have to capture the service children elements (ports) here as they get munged later
                                                    if (valid) {
                                                        file.serviceChildren = postParse.captureServiceChildren(file.doc);
                                                        postParse.updateSchemaNamespaces(file);
                                                    }
                                                } catch (e) {
                                                    if (!isXMLSuffix) {
                                                        reject = true;
                                                        def.reject(parseUtils.cleanupError(e));
                                                    }
                                                }
                                            }
                                            zipFile.readEntry();

                                        });
                                    }
                                });
                            }
                        });
                        // End of all zip files
                        zipFile.on('end', function() {
                            def.resolve(files);
                        });
                    }
                });
            } else {
                var file = {
                    filename: filename,
                    fullName: filename,
                    type: 'wsdl',
                    content: rawContent,
                    context: 'cmd'
                };
                try {
                    if (rawContent == filename) {
                        file.filename = 'MEMORY';
                        file.fullName = 'MEMORY';
                    }
                    if (file.content == null || file.content.length == 0) {
                        throw new Error('The file has no content: ' + file.filename);
                    }
                    parseUtils.contentToXMLorWSDL(file);
                    if (file.json.definitions) {
                        var wsdlGood = parseUtils.validateWSDLJson(file.json, file.filename);
                        if (wsdlGood.valid) {
                            files.push(file);
                            file.type = 'wsdl';
                            var namespaces = file.doc.definitions.xmlns;
                            file.namespaces = namespaces;
                        } else {
                            throw new Error(wsdlGood.reason);
                        }
                    } else if (file.json.schema) {
                        files.push(file);
                        file.type = 'xsd';
                        file.namespaces = {};
                    } else {
                        throw new Error('Failed to parse WSDL or XSD: ' + file.filename);
                    }
                    // have to capture the service children elements (ports) here as they get munged later
                    file.serviceChildren = postParse.captureServiceChildren(file.doc);
                    postParse.updateSchemaNamespaces(file);
                    def.resolve(files);
                } catch (e) {
                    def.reject(parseUtils.cleanupError(e));
                }
            }
        }, function(fileErr) {
            def.reject(fileErr);
        });
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}

exports.getJsonForWSDL = getJsonForWSDL;
exports.getWSDLServices = getWSDLServices;
exports.findWSDLForServiceName = findWSDLForServiceName;
exports.sanityCheckDefinition = sanityCheckDefinition;
