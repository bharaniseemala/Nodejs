/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

const u = require('../lib/utils.js');
const parse = require('../lib/parse.js');
const postParse = require('../lib/postParse.js');
const dictionary = require('../lib/dictionary.js');
const genSOAP = require('../lib/generateSOAP.js');
const genDefs = require('../lib/generateDefs.js');
const postGen = require('../lib/postGenerate.js');
const example = require('../lib/generateExamples.js');
const rest = require('../lib/createRESTfromSOAP.js');

var _ = require('lodash');

/**
* Convenience Method for v6
* @param {FileEntry} wsdlEntry - from findWSDLForServiceName
* @param {String} serviceName - Process the indicated service
* @param {String} wsdlId - often the filename
* @param {Object} options
*   defaults: object to merge into openapi
* @return {Object} swagger
*/
function generateSwaggerForWsdlProxy(wsdlEntry, serviceName, wsdlId, options) {
    let inOptions = options || {};
    inOptions.type = 'wsdl';
    let openapi = getSwaggerForService(wsdlEntry, serviceName, wsdlId, inOptions);
    if (inOptions.defaults) {
        let defaults = u.deepClone(inOptions.defaults);
        // mergeWith is not available in lodash^3.10
        // so do a merge and assign
        // _.mergeWith(openapi, defaults, customizer);
        _.merge(openapi, defaults);
        if (defaults.securityDefinitions) {
            openapi.securityDefinitions = defaults.securityDefinitions;
        }
        if (defaults.security) {
            openapi.security = defaults.security;
        }
    }
    return openapi;
}

/**
* Convenience Method for v6
* @param {FileEntry} wsdlEntry - from findWSDLForServiceName
* @param {String} serviceName - Process the indicated service
* @param {String} wsdlId - often the filename
* @param {Object} options
*   defaults: object to merge into openapi
*   badgerfishDefs: default true.  Json definitions in badgerfish form
*   mapOptions: setting to use for autogenerated assembly map. The default is no map.options
*       mapOptions.includeEmptyXMLElements
*       mapOptions.namespaceInheritance
*       mapOptions.inlineNamespaces
*   mapSOAPFaults: default true
*   decodeGatewayScript : default false
* @return {Object} swagger
*/
function generateSwaggerForSoapToRest(wsdlEntry, serviceName, wsdlId, options) {
    let inOptions = options || {};
    if (typeof inOptions.mapSOAPFaults == 'undefined') {
        inOptions.mapSOAPFaults = true;
    }
    if (typeof inOptions.badgerfishDefs === 'undefined') {
        inOptions.badgerfishDefs = true;
    }
    inOptions.generateFaultDefs = inOptions.mapSOAPFaults;
    let openapi_soap = getSwaggerForService(wsdlEntry, serviceName, wsdlId, inOptions);

    // Create a SOAP->REST api.
    //  - embeds the openapi_soap as a target
    //  - creates rest paths/operations that match the soap operations
    //  - creates an assembly operation-switch which maps the REST api to the soap proxy
    inOptions.type = 'wsdl-to-rest';
    let openapi_rest = rest.getSwaggerForSOAPREST(openapi_soap, inOptions);
    if (inOptions.defaults) {
        let defaults = u.deepClone(inOptions.defaults);
        // mergeWith is not available in lodash^3.10
        // so do a merge and assign
        // _.mergeWith(openapi_rest, defaults, customizer);
        _.merge(openapi_rest, defaults);
        if (defaults.securityDefinitions) {
            openapi_rest.securityDefinitions = defaults.securityDefinitions;
        }
        if (defaults.security) {
            openapi_rest.security = defaults.security;
        }
    }
    return openapi_rest;
}

function customizer(objValue, srcValue, key) {
    // The securityDefinitions array and security object are overwritten (not merged)
    if (key === 'securityDefinitions') {
        return srcValue;
    } else if (key === 'security') {
        return srcValue;
    }
}

/**
* Convenience Method for v6
* @deprecated addTargetOpenApi
* @param {FileEntry} openApi - existing openApi
* @param {FileEntry} wsdlEntry - from findWSDLForServiceName
* @param {String} serviceName - Process the indicated service
* @param {Object} options
* @return {Object} swagger
*/
function addTargetSwaggerFromWsdl(openApi, wsdlEntry, serviceName, options) {
    let inOptions = options || {};
    inOptions.type = 'wsdl';
    let tgtOpenApi = getSwaggerForService(wsdlEntry, serviceName, serviceName, inOptions);
    tgtOpenApi = updateRefs(tgtOpenApi, serviceName);

    if (!openApi['x-ibm-configuration'].targets) {
        openApi['x-ibm-configuration'].targets = {};
    }
    openApi['x-ibm-configuration'].targets[serviceName] = tgtOpenApi;
    return openApi;
}

function updateRefs(json, serviceName) {
    let jsonString = JSON.stringify(json);

    let src = '#/';
    let tgt = '#/x-ibm-configuration/targets/' + serviceName + '/';

    jsonString = jsonString.replace(new RegExp(src, 'g'), tgt);
    return JSON.parse(jsonString);
}

/**
 * Get the Swagger for the service
 * @method getSwaggerForService
 * @param {FileEntry} wsdlEntry - from findWSDLForServiceName
 * @param {String} serviceName - Process the indicated service
 * @param {String} wsdlId
 * @param {Object} options
*   type: default 'wsdl'
 * @return {Object} swagger
 **/
function getSwaggerForService(wsdlEntry, serviceName, wsdlId, inputFlags) {
    if (!inputFlags) {
        inputFlags = {
            inlineAttributes: true, // Actually want to always do this because UI doesn't understand out-line attributes
            suppressExamples: false, // Suppress examples may be true if importing implementation service
            type: 'wsdl',
        };
    }
    inputFlags.fromGetDefinitionsForXSD = false;
    inputFlags.rootElementList = null;
    return _getSwaggerForService(wsdlEntry, serviceName, wsdlId, inputFlags);
}

/**
 * This utility implementation is used for both getSwaggerForService and getDefinitionsForXSD
 * @method _getSwaggerForService
 * @param {FileEntry} wsdlEntry - from findWSDLForServiceName
 * @param {String} serviceName - Process the indicated service
 * @param {String} wsdlId
 * @param {Object} inputFlags
 * @return {Object} swagger
 **/
function _getSwaggerForService(wsdlEntry, serviceName, wsdlId, inputFlags) {
    if (typeof inputFlags.inlineAttributes == 'undefined') {
        inputFlags.inlineAttributes = true;
    }
    if (typeof inputFlags.type == 'undefined') {
        inputFlags.type = 'wsdl';
    }
    if (typeof wsdlId == 'undefined') {
        wsdlId = 'undefined';
    }

    if (wsdlEntry == null) {
        // This will occur if findWSDLForServiceName did not find any wsdlEntry objects for serviceName
        // Throw an error that will be useful for the customer.
        throw new Error('A service named "' + serviceName +
      '" was not found in the wsdl. Please specify a service that is present in the wsdl. ' +
      'You may need to change the Title of your API to match the name of a service in the wsdl file.');
    }

    // The wsldEntry contains the preparsed and merged information from node soap (see parse.js for details)

    let wsdlJson = wsdlEntry.json;
    let namespaces = wsdlEntry.namespaces;

    let schemaList = [];
    if (wsdlJson.definitions.types && wsdlJson.definitions.types.schema) {
        schemaList = u.makeSureItsAnArray(wsdlJson.definitions.types.schema);
    }
    let tns = '';
    if (wsdlJson.definitions['undefined'] && wsdlJson.definitions['undefined'].targetNamespace) {
        tns = wsdlJson.definitions['undefined'].targetNamespace;
    }

    // Build a dictionary.
    // Each schema type, element or attribute has an nsName, which is its dictionary index
    // The node soap object, qualification, and namespace information is stored and is accessible
    // from the dictionary.  For example dict.dictEntry[nsName].schema is the node soap object
    let dict = dictionary.buildDictionary(schemaList, postParse.isWSAddressing(wsdlJson), namespaces, tns);

    // Now start the generation of the Open API (Swagger) document by generating the SOAP/WSDL
    // information.  While processing a refMap is produced which records the references to the
    // objects in the dictionary
    let refMap = {};
    let genSOAPOptions = {
        type: inputFlags.type,
        generateFaultDefs: inputFlags.generateFaultDefs
    };
    let swagger = genSOAP.generateSOAP(serviceName, wsdlId, wsdlJson, namespaces, wsdlEntry.serviceChildren, dict, refMap, genSOAPOptions);

    // If in getDefinitionsForXSD mode, add references to the xsd elements.
    if (inputFlags.fromGetDefinitionsForXSD) {
        addXSDElementReferences(refMap, dict, inputFlags);
        if (swagger.definitions['Security']) {
            delete swagger.definitions['Security'];
        }
    }

    // Now generate the definitions for each of the references in the refMap
    genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces);

    // The path information generated during generateSOAP is incomplete and requires
    // patching after the swagger definitions are generated.
    genSOAP.patchPaths(swagger, dict);

    // Now consider polymorphism.
    // For example,
    //        a) Ext type extends Base type.
    //        b) There is a reference to Base type
    // The code above will generate the swagger definition for Base, but now must find
    // and generate the swagger definition of Ext because it extends Base.
    let limit = 0;
    do {
        // Get additional definitions for subtypes of referenced base types.
        refMap = genDefs.getExtraReferencesForSubTypes(dict.subTypes, swagger);

        // Generate definitions for the new types
        genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces);

        // Rinse an repeat.  Adding a type may have resulted in new references.
        limit++;
    } while (Object.keys(refMap).length > 0 && limit < 10);

    // Add friendly definitions for header insertion
    if (inputFlags.fromGetDefinitionsForXSD) {
        addHeaderDefinitionsForXSD(swagger, dict);
    }

    // Finally add the special reserved type if we detect that messages were added to it
    if (dict.dictEntry[dictionary.RESERVED_DEF] &&
        dict.dictEntry[dictionary.RESERVED_DEF].schema &&
        dict.dictEntry[dictionary.RESERVED_DEF].schema.annotation) {
        let refMap = {};
        genDefs.addReference(refMap, dictionary.RESERVED_DEF, {});
        genDefs.generateSwaggerDefinitions(swagger.definitions, refMap, dict, namespaces);
    }


    // Each basetype needs a discriminator
    for (let baseType in dict.subTypes) {
        if (swagger.definitions[baseType]) {
            swagger.definitions[baseType]['x-ibm-discriminator'] = true;
        }
    }

    // If a non-default reference is made to a portion of a polymorhic hierarchy,
    // then the entire polymorphic hierarchy must be reproduced with the reference.
    postGen.duplicatePolyHierarchy(swagger, dict);

    // A type is normally only referenced with either nillable=true or nillable=false.
    // Though uncommon, we could have a situation where a type is referenced sometimes
    // with nillable=true and sometimes with nillable=false.  In though circumstances
    // we must duplicate the type definitions (so that we have one for nill and one for not nill)
    // and patch the references.
    postGen.fixupForNilAndNonNil(swagger.definitions, dict);

    // The UI doesn't support $ref for attributes because it doesn't
    // follow the $ref to see if it is an attribute.  So inline the
    // attributes.
    if (inputFlags.inlineAttributes) {
        postGen.inlineSwaggerAttributes(swagger);
    }

    // Make sure default values match the type of the object
    postGen.adjustDefaults(swagger.definitions, swagger.definitions);

    // The algorithms to add definitions may result in unreferenced definitions.
    // These can be removed.
    postGen.removeUnreferencedDefinitions(swagger, inputFlags.fromGetDefinitionsForXSD);

    // Remove redundant namespaces
    swagger = postGen.optimizeNamespaces(swagger);

    // now generate the example XML for all required types
    if (!inputFlags.suppressExamples) {
        example.generateExamples(swagger, dict);
    }
    return u.checkAndFix(swagger);
}

/**
* Add raw element references
*/
function addXSDElementReferences(refMap, dict, inputFlags) {
    // Walk all of the root elements in the dictEntry.
    for (let nsName in dict.elementNS) {
        // Get the original name of the element (not the mangled definition name)
        let originalName = dict.originalNames[nsName].name;

        // If the name is in the list (or there is no list), then process it
        if ((!inputFlags.rootElementList || inputFlags.rootElementList.length == 0) ||
            inputFlags.rootElementList.indexOf(originalName) > -1 ||
            inputFlags.rootElementList.indexOf(nsName) > -1) {

            // Add the xmlName to the reference
            genDefs.addReference(refMap, nsName, {
                xmlName: originalName
            });

            // Find and add a reference to the type
            if (dict.dictEntry[nsName] &&
                dict.dictEntry[nsName].schema &&
                dict.dictEntry[nsName].schema['undefined'] &&
                dict.dictEntry[nsName].schema['undefined'].linkup) {
                genDefs.addReference(refMap,
                  dict.dictEntry[nsName].schema['undefined'].linkup,
                  {});
            }
        }
    }
}

/**
* add friendly header definitions that wrap the element
*/
function addHeaderDefinitionsForXSD(swagger, dict) {
    // Walk all of the root elements.
    for (let nsName in dict.elementNS) {
        if (dict.originalNames[nsName]) {
            let elementNSName = nsName + '_of_' + dict.originalNames[nsName].name;
            if (swagger.definitions[elementNSName]) {
                // Get the original name of the element (not the mangled definition name)
                let origElementName = swagger.definitions[elementNSName].xml.name;
                let headerNsName = nsName + '_Header';
                swagger.definitions[headerNsName] = {};
                swagger.definitions[headerNsName].xml = {};

                swagger.definitions[headerNsName].xml.namespace = swagger.definitions[elementNSName].xml.namespace;
                swagger.definitions[headerNsName].xml.prefix = swagger.definitions[elementNSName].xml.prefix;
                swagger.definitions[headerNsName].type = 'object';
                swagger.definitions[headerNsName].properties = {};
                swagger.definitions[headerNsName].properties[origElementName] = {};
                swagger.definitions[headerNsName].properties[origElementName]['$ref'] = '#/definitions/' + elementNSName;
            }
        }
    }
}

exports.generateSwaggerForSoapToRest = generateSwaggerForSoapToRest;
exports.generateSwaggerForWsdlProxy = generateSwaggerForWsdlProxy;
exports.validateSwaggerFromWsdl = addTargetSwaggerFromWsdl;
exports.getSwaggerForService = getSwaggerForService;
exports._getSwaggerForService = _getSwaggerForService;
