/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Valiate functions for the apiconnect-wsdl parser
**/

var u = require('../lib/utils.js');
var openApiV3 = require('../lib/openApiV3');
var rest = require('../lib/createRESTfromSOAP');

var q = require('q');
var sway = require('sway');
var swaggerParser = require('swagger-parser');
var util = require('util');

/**
 * Inspects a result produced by createOpenApi and adds messages and statistics
 */
function inspectOpenApi(result) {
    result.statistics = result.statistics || {};
    result.messages = result.messages || [];
    try {
        let text = util.inspect(result.openapi, {
            depth: null
        });
        let isSoapRest = result.openapi['x-ibm-configuration'].type === 'wsdl-to-rest';

        result.statistics.referenceCount = (text.match(/\$ref/g) || []).length;
        result.statistics.definitionCount = Object.keys(definitionsOrSchemas(result.openapi)).length;

        let regex = /(APIC_MESSAGE[^)]*)/gi;
        let matches = text.match(regex);
        let total;
        if (matches) {
            for (let i = 0; i < matches.length; i++) {
                let message = matches[i].substring(14);
                if (total.indexOf('(' + message + ')') < 0) {
                    total += '(' + message + ')';
                    result.messages.push({ message: message });
                }
            }
        }
    } catch (err) {
        result.messages.push(err.message);
    }
    return result;
}

/**
 * Checks the (open api) swagger object for various problems.
 * Used in automated testing to help ensure that only valid swagger objects are produced.
 * Also used to analyze customer provided swaggers (which could be from old products or hand generated)
 * Return a promise
 */
function sniffSwagger(swagger, flags) {
    var def = q.defer();
    try {
        let isSoapRest = swagger['x-ibm-configuration'].type === 'wsdl-to-rest';
        var errorText = '';

        // Look for the words in the swagger.
        // This is an indication that there is a problem.
        var text = util.inspect(swagger, {
            depth: null
        });
        var words = [
            'https://www.w3.org/2003/05/soap-envelope/', // Bad namespace
            'https://www.w3.org/2003/05/soap-envelope' // Bad namespace
        ];
        for (var w = 0; w < words.length; w++) {
            var word = words[w];
            var index = text.indexOf(word);
            if (index >= 0) {
                errorText += 'ERROR: Found "' + word + '": ' + text.substring(index - 100, index + 200) + '\n';
            }
        }

        // Check for very large files
        // Note this is in JSON format versus YAML format
        // The management node max size is about 16M
        if (text.length > 10000000) {
            errorText += 'WARNING: Swagger file is ' + text.length + ' characters long.\n';
        }

        // Count $ref, exceeding 4000 probably means that this won't publish
        let countRefs = (text.match(/\$ref/g) || []).length;
        if (countRefs > 4000) {
            errorText += 'WARNING: Number of refs is ' + countRefs + '.\n';
        }

        // Excessive number of definitions may prevent publishing
        let numDefs = Object.keys(definitionsOrSchemas(swagger)).length;
        if (numDefs > 1000) {
            errorText += 'WARNING: Number of definitions is ' + numDefs + '.\n';
        }

        // Check unique names
        if (flags && flags.checkMessages) {
            let defs = definitionsOrSchemas(swagger);
            for (let ncName in defs) {
                let d = defs[ncName];
                let uniq = d['x-xsi-type-uniquename'];
                if (uniq && !defs[uniq] && (d.allOf || d['x-ibm-discriminator'])) {
                    errorText += 'ERROR: x-xsi-type-uniquename ' + uniq + ' of ' + ncName + ' is not found.\n';
                }
            }
        }

        // Look for the APICMessages in the swagger.
        // This is an indication that there is a problem.
        if (flags && flags.checkMessages) {
            var regex = /(APIC_MESSAGE[^)]*)/gi;
            var matches = text.match(regex);
            if (matches) {
                for (var i = 0; i < matches.length; i++) {
                    errorText = errorText + matches[i] + '\n';
                }
            }
        }

        // Check example xml to ensure it is valid
        var exampleErrs = validateExampleXML(swagger);
        if (exampleErrs) {
            errorText += exampleErrs;
        }

        // Find very deep inlines, which could indicate a problem.
        var context = {};
        findDeepInlines(swagger, context, isSoapRest);
        if (context.list) {
            for (var ncName in context.list) {
                if (!ncName.endsWith('Fault') &&
            !ncName.endsWith('Input') &&
            !ncName.endsWith('Output') &&
            ncName != 'SubCode__SOAP12' &&
            ncName != 'Security') {
                    errorText += 'INFO: ' + ncName + ' has ' + context.list[ncName] + ' depth of inlines. \n';
                }
            }
        }
        if (context.errMsgs) {
            errorText += context.errMsgs;
        }

        // Make sure each prefix is defined to a single namespace.
        var map = getNamespaces(swagger);
        for (var s in map) {
            for (var p in map[s]) {
                if (map[s][p].length > 1) {
                    errorText += 'WARNING: prefix ' + p + ' has multiple namespaces ' + map[s][p] + ' \n';
                }
            }
        }

        if (errorText.length > 0) {
            def.reject(new Error(errorText));
        } else {
            if (text.length < 1000000) {
                validateSwagger(swagger).then(function() {
                    def.resolve();
                }, function(err) {
                    def.reject(err);
                });
            } else {
                def.resolve();
            }
        }
    } catch (e) {
        def.reject(e);
    }
    return def.promise;
}

/**
* Runs a validator against the swagger and returns a promise.
*/
function validate(swagger) {

    swagger = u.deepClone(swagger);
    replaceRefsWithStringType(swagger);

    if (swagger.openapi) {
        return openApiV3.validate(swagger);
    }

    // Run the swagger through a validator
    let apicValidate = null;
    try {
        apicValidate = require('apiconnect-validate');
    } catch (e) {
        // Continue
    }

    if (apicValidate) {
        // In development, the APIC Validator is available
        return validateSwaggerWithAPICValidator(swagger);
    }

    // In production, only sway is available
    return validateSwaggerWithSway(swagger);
}

/**
* Utility to replace refs with a string so that we can validate it quickly with sway.
*/
function replaceRefsWithStringType(obj) {
    if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            replaceRefsWithStringType(obj[j]);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == '$ref') {
                    delete obj[key];
                    obj.type = 'string';
                    return;
                } else {
                    // recurse
                    replaceRefsWithStringType(obj[key]);
                }
            }
        }
    }
}

/**
* Build a namespaces map of prefix->namespace for
* definitions and embedded services.
*/
function getNamespaces(swagger) {
    var context = {
        service: null,
        map: {}
    };
    buildNamespaceMap(swagger, context);
    return context.map;
}

function buildNamespaceMap(obj, context) {
    if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            buildNamespaceMap(obj[j], context);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == 'definitions' || key == 'schemas') {
                    if (obj['x-ibm-configuration'] &&
                        obj['x-ibm-configuration']['wsdl-definition'] &&
                        obj['x-ibm-configuration']['wsdl-definition'].service) {
                        context.service = obj['x-ibm-configuration']['wsdl-definition'].service;
                        if (!context.map[context.service]) {
                            context.map[context.service] = {};
                        }
                    } else {
                        context.service = null;
                    }
                    buildNamespaceMap(obj[key], context);
                    context.service = null;
                } else if (key == 'xml') {
                    if (context.service) {
                        if (obj.xml.prefix) {
                            if (!context.map[context.service][obj.xml.prefix]) {
                                context.map[context.service][obj.xml.prefix] = [];
                            }
                            if (context.map[context.service][obj.xml.prefix].indexOf(obj.xml.namespace) < 0) {
                                context.map[context.service][obj.xml.prefix].push(obj.xml.namespace);
                            }
                        }
                    }
                } else {
                    buildNamespaceMap(obj[key], context);
                }
            }
        }
    }
}

/**
* Walk the object and find deep nestings of xso (xml schema objects).
* Deep nestings may indicate a problem with the generator or might indicate
* an usual shape of the input schema.
* While walking the object, other validation checks are also performed.
*/
function findDeepInlines(obj, context, isSoapRest) {
    if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            findDeepInlines(obj[j], context, isSoapRest);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == 'definitions'  || key == 'schemas') {
                    context.inDefinitions = true;
                    var ref = obj[key];
                    findDeepInlines(obj[key], context, isSoapRest);
                    context.inDefinitions = false;
                } else if (context.inDefinitions  && !context.ncName) {
                    context.ncName = key;
                    context.properties = 0;
                    // Make sure this definition has a xml construct
                    if (!isSoapRest && !obj[key].xml) {
                        // The parser probably should put out an xml construct for
                        // definitions for SOAP constructs, but it currently does not.
                        if (!(key.endsWith('Header') ||
                            key.endsWith('HeaderOut') ||
                            key.endsWith('Output') ||
                            key.endsWith('Input') ||
                            key.endsWith('Fault')  ||
                            key == 'APIC__RESERVED')) {
                            if (!context.errMsgs) {
                                context.errMsgs = '';
                            }
                            context.errMsgs += 'WARNING: No xml found for definition: ' + key + '\n';
                        }
                    }
                    findDeepInlines(obj[key], context, isSoapRest);
                    context.ncName = false;
                } else if (context.ncName && key == 'properties') {
                    if (Object.keys(obj[key]).length > 0) {
                        if (context.ncName) {
                            context.properties++;
                            if (context.properties >= 5) {
                                if (!context.list) {
                                    context.list = {};
                                }
                                context.list[context.ncName] = context.properties;
                            }
                        }
                        findDeepInlines(obj[key], context, isSoapRest);

                        // Look for malformed properties
                        for (var key2 in obj[key]) {
                            if (obj[key][key2] && typeof obj[key][key2] === 'object') {
                                if (!obj[key][key2].type  && !obj[key][key2]['$ref'] &&  !obj[key][key2]['allOf']  && !obj[key][key2]['x-anyType']) {
                                    if (!context.errMsgs) {
                                        context.errMsgs = '';
                                    }
                                    context.errMsgs += 'ERROR: No type, $ref, allof or x-anyType for ' + key2 + ' in ' + context.ncName + '\n';
                                }
                                if (obj[key][key2].type  && obj[key][key2]['$ref'] ||
                                    obj[key][key2].type  && obj[key][key2]['allOf'] ||
                                    obj[key][key2]['$ref'] && obj[key][key2]['allOf'])  {
                                    if (!context.errMsgs) {
                                        context.errMsgs = '';
                                    }
                                    context.errMsgs += 'ERROR: Conflicting type, $ref, and allof for ' + key2 + ' in ' + context.ncName + '\n';
                                }
                            }
                        }

                        if (context.ncName) {
                            context.properties--;
                        }

                    }
                } else {
                    findDeepInlines(obj[key], context, isSoapRest);
                }
            }
        }
    }
}

/**
* ValidateSwagger with the swaggerParser
*/
function validateSwagger(swagger) {
    var validateDef = q.defer();
    swaggerParser.validate(swagger, {
        allow: {
            unknown: false,
            empty: false
        },
        $refs: {
            external: false
        },
        validate: {
            spec: true
        }
    }).then(function(api) {
        validateDef.resolve();
    }, function(err) {
        var returnError = '';
        var lines = err.message.match(/[^\r\n]+/g);
        for (var i = 1; i < lines.length; i++) {
            // Prune silly stuff
            var line = lines[i];
            if (line.indexOf('Expected type number but found type string') >= 0 ||
                line.indexOf('JSON_OBJECT_VALIDATION_FAILED') >= 0 ||
                line === ' ') {
                // Accept
            } else {
                returnError = returnError + line + '\n';
            }
        }
        if (returnError.length > 0) {
            returnError = lines[0] + '\n' + returnError; // Add error message header line
            validateDef.reject(new Error(returnError));
        } else {
            validateDef.resolve();
        }
    });
    return validateDef.promise;
}

/**
* ValidateSwagger with raw Sway parser
*/
function validateSwaggerWithSway(definition) {
    var validateDef = q.defer();
    sway.create({ definition: definition }).then(function(api) {
        api.registerValidator(swayAdditionalChecks);
        var swayResponse = api.validate();
        var returnError = '';
        for (var i = 0; i < swayResponse.errors.length; i++) {
            if (swayResponse.errors[i].message.indexOf('Expected type number but found type string') >= 0) {
                // Ignore
            } else if (swayResponse.errors[i].message.indexOf('Not a valid response definition') >= 0) {
                // Ignore because it is redundant and normally is accompanied by real error
            } else if (swayResponse.errors[i].message.indexOf('Not a valid parameter definition') >= 0) {
                // Ignore because it is redundant and normally is accompanied by real error
            } else if (swayResponse.errors[i].message.indexOf('Not a valid schema items definition') >= 0) {
                // Ignore because it is redundant and normally is accompanied by real error
            } else {
                returnError = returnError + util.inspect(swayResponse.errors[i], {
                    depth: null,
                    colors: true
                }) + '\n';
            }
        }
        for (i = 0; i < swayResponse.warnings.length; i++) {
            if (swayResponse.warnings[i].message.indexOf('Definition is not used') >= 0) {
                // Ignore
            } else if (swayResponse.warnings[i].message.indexOf('Extra JSON Reference properties will be ignored: description') >= 0) {
                // Known deviation
            } else {
                returnError = returnError + util.inspect(swayResponse.warnings[i], {
                    depth: null,
                    colors: true
                }) + '\n';
            }
        }
        if (returnError.length > 0) {
            validateDef.reject(new Error(returnError));
        } else {
            validateDef.resolve();
        }
    });
    return validateDef.promise;
}

/**
* ValidateSwagger with APIC Validator (which uses sway)
*/
function validateSwaggerWithAPICValidator(definition) {
    var validateDef = q.defer();
    var validator;
    try {
        validator = require('apiconnect-validate');
    } catch (e) {
        validateDef.resolve();  // Not available, jus continue
        return validateDef.promise;
    }
    let artifact = {
        type: 'swagger',
        raw: '',
        data: definition
    };
    validator.validateArtifact([ artifact ], { jsonRefs: [] }).then(function(obj) {
        var returnError = '';
        var swayResponse = obj['undefined'];
        for (let i = 0; i < swayResponse.error.length; i++) {
            returnError = returnError + util.inspect(swayResponse.error[i], {
                depth: null,
                colors: true
            }) + '\n';
        }
        for (let h = 0; h < swayResponse.validation.length; h++) {
            if (swayResponse.validation[h].error) {
                for (let i = 0; i < swayResponse.validation[h].error.length; i++) {
                    let error = swayResponse.validation[h].error[i];
                    if (error.message.indexOf('Expected type number but found type string') >= 0) {
                        // Ignore
                    } else if (error.message.indexOf('Not a valid response definition') >= 0) {
                        // Ignore because it is redundant and normally is accompanied by real error
                    } else if (error.message.indexOf('Not a valid parameter definition') >= 0) {
                        // Ignore because it is redundant and normally is accompanied by real error
                    } else if (error.message.indexOf('Not a valid schema items definition') >= 0) {
                        // Ignore because it is redundant and normally is accompanied by real error
                    } else {
                        returnError = returnError + util.inspect(error, {
                            depth: null,
                            colors: true
                        }) + '\n';
                    }
                }
            }
            if (swayResponse.validation[h].warning) {
                for (let i = 0; i < swayResponse.validation[h].warning.length; i++) {
                    let warning = swayResponse.validation[h].warning[i];
                    if (warning.message.indexOf('Definition is not used') >= 0) {
                        // Ignore
                    } else if (warning.message.indexOf('Extra JSON Reference properties will be ignored: description') >= 0) {
                        // Known deviation
                    } else {
                        returnError = returnError + util.inspect(warning, {
                            depth: null,
                            colors: true
                        }) + '\n';
                    }
                }
            }
        }

        if (returnError.length > 0) {
            validateDef.reject(new Error(returnError));
        } else {
            validateDef.resolve();
        }
    });
    return validateDef.promise;
}

function swayAdditionalChecks(api) {
    var response = {
        errors: [],
        warnings: [],
    };
    return response;
}

/**
* Find the examples (which are xml) and validate them with a DOMParser.
* Errors in the examples may indicate problems in the generation code
* because the example generator walks the swagger to produce the example.
*/
function validateExampleXML(swagger) {
    var errorText = null;
    try {
        let ds = definitionsOrSchemas(swagger);
        if (ds) {
            for (var ncName in ds) {
                var def = ds[ncName];
                var xml = def.example;
                if (xml && xml.length < 10000) {
                    try {
                        var DOMParser = require('xmldom').DOMParser;
                        var doc = new DOMParser().parseFromString(xml);
                    } catch (err) {
                        errorText = err + '\n';
                    }
                }
            }
        }
    } catch (e) {
        return e + '\n' + errorText;
    }
    return errorText;
}

/**
* @returns defintions (V2) or components.schemas (V3)
*/
function definitionsOrSchemas(swagger) {
    if (swagger.openapi) {
        return swagger.components ? swagger.components.schemas : null;
    }
    return swagger.definitions;
}

exports.getNamespaces = getNamespaces;
exports.inspectOpenApi = inspectOpenApi;
exports.sniffSwagger = sniffSwagger;
exports.replaceRefsWithStringType = replaceRefsWithStringType;
