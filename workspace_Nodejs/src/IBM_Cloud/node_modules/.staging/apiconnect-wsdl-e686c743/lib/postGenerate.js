/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Functions that occur after the swagger generation for the apiconnect-wsdl parser
**/

var u = require('../lib/utils.js');
const dictionary = require('../lib/dictionary.js');


/**
* Duplicate polymorphic hierarchy for each base definitions
*/
function duplicatePolyHierarchy(swagger, dict) {
    /**
     * If the root element is defined with a type.  Example:
     *  <xs:element name="Foo" type="s1:Base" />
     *
     * then definitions will be created for Foo and Base (Foo_s1 and Base_s1).
     *
     * If there are polymorphic extensions of Base (example Ext1 and Ext2)
     * then we need to duplicate these for Foo so that the assemply map policy works properly.
     * This function produces the duplicates (named Ext1_s1_for_Foo_s1 and Ext_s1_for_Foo_s1).
     *
     * Reproducing hierarchies could cause a large number of new definitions.  So
     * first see if we can do some optimizations.
     */

    var ncName, def;

    // Create a potential map (element ns name-> type ns name) to see which element
    // definitions can be replaced with type defintions
    var potential = {};
    try {
        potential = optimizeRootElementsMap(swagger.definitions, dict);
    } catch (e) {
        console.log('Problem constructing element optimization map..processing continues ' + e);
    }

    // Create map (nsName -> subtype info) to assist in creation of duplicate hierarchies
    var map = {};
    try {
        if (swagger.definitions) {
            for (ncName in swagger.definitions) {
                def = swagger.definitions[ncName];
                let dictEntry = dict.dictEntry[ncName];
                if (def['x-ibm-discriminator']) {

                    // Get the original typeNS
                    let typeNS = def['x-xsi-type-uniquename'];
                    // Get all subtypes
                    if (typeNS && dict.subTypes[typeNS] && typeNS != ncName) {
                        map[ncName] = {};
                        subTypeMap(map[ncName], dict.subTypes, typeNS, ncName, ncName);
                    }
                }
            }
        }
    } catch (e) {
        console.log('Problem constructing subTypes map..processing continues ' + e);
    }

    // Determine how many duplicate definitions will be created for elements
    // if we don't optimize elements
    var forElements = 0;
    for (var e in potential) {
        if (map[e]) {
            forElements += Object.keys(map[e]).length;
        }
    }

    // If the number of duplicate definitions for elements is sufficiently
    // large then replace the elements with their type.
    if (forElements > 100) {
        replaceRefs(swagger, potential);
        for (let defName in potential) {
            delete swagger.definitions[defName];
        }
    }

    // Now do the hierarchy duplication
    var count = 0;
    if (swagger.definitions) {
        for (ncName in swagger.definitions) {
            def = swagger.definitions[ncName];
            if (map[ncName]) {
                for (var subType in map[ncName]) {
                    var newNCName = map[ncName][subType].name;
                    if (!swagger.definitions[newNCName] &&
                         swagger.definitions[subType]) {
                        // Create the new ncName using the subtype
                        swagger.definitions[newNCName] = u.deepClone(swagger.definitions[subType]);
                        // ..but the highest level xml is same as the original ncName
                        swagger.definitions[newNCName].xml = u.deepClone(def.xml);
                        count++;
                        // If there is an allOf, change it to the new base
                        if (swagger.definitions[newNCName]['allOf'] && swagger.definitions[newNCName]['allOf'][0]['$ref']) {
                            swagger.definitions[newNCName].allOf[0]['$ref'] = '#/definitions/' + map[ncName][subType].base;
                        }
                        swagger.definitions[newNCName]['x-xsi-type-uniquename'] = newNCName;
                    }
                }
            }
        }
    }
}

function optimizeRootElementsMap(definitions, dict) {
    var potential = [];

    if (definitions) {
        for (var ncName in definitions) {
            // If pattern is <xs:element name="Foo" type="s1:Bar" />
            let dictEntry = dict.dictEntry[ncName];
            if (dictEntry &&
                dictEntry.schema &&
                dictEntry.schema['undefined'] &&
                dictEntry.schema['undefined'].linkup) {
                var linkup = dictEntry.schema['undefined'].linkup;
                // Ensure that both the element and type definitions exist and they have same qualification
                if (!dictEntry.preventOptimize &&
                    ncName != linkup &&
                    definitions[linkup] &&
                    definitions[linkup].xml &&
                    definitions[ncName].xml &&
                    definitions[ncName].xml.namespace == definitions[linkup].xml.namespace) {
                    // Only attempt optimization if the type is a base of a polymorphic hierarchy
                    if (dict.subTypes[linkup]) {
                        potential[ncName] = linkup;
                    }
                }
            }
        }
    }
    // console.log("Potential element optimizations = " + Object.keys(potential).length);
    return potential;
}

function subTypeMap(map, subTypes, base, newBase, root) {
    if (subTypes[base]) {
        var subTypeList = subTypes[base];
        for (var i = 0; i < subTypeList.length; i++) {
            var subType = subTypeList[i];
            map[subType] = {};
            map[subType].base = newBase;
            map[subType].name = subType + '_for_' + root;
            subTypeMap(map, subTypes, subType, map[subType].name, root);
        }
    }
}

/**
* Replaces $refs with the new name from the map
*/
function replaceRefs(obj, map) {
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (var j = 0; j < len; j++) {
            // recurse array element
            replaceRefs(obj[j], map);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == '$ref') {
                    var ref = obj[key];
                    var words = ref.split('/');
                    var ncName = words[words.length - 1];
                    if (map[ncName]) {
                        obj['$ref'] = '#/definitions/' + map[ncName];
                    }
                    return;
                } else {
                    // recurse
                    replaceRefs(obj[key], map);
                }
            }
        }
    }
}

/**
 * Replace $ref for attributes with inlined definitions
 * and remove the attribute definitions
 */
function inlineSwaggerAttributes(swagger) {

    var attrs = [];
    var attrRefs = [];

    // Find all of the ncNames for the attributes
    for (var ncName in swagger.definitions) {
        var def = swagger.definitions[ncName];
        if (def.xml && def.xml.attribute) {
            attrs.push(ncName);
            attrRefs.push('#/definitions/' + ncName);
        }
    }

    // Replace the $refs
    if (attrs.length > 0) {
        for (ncName in swagger.definitions) {
            inlineAttrRef(swagger.definitions[ncName], attrRefs, attrs, swagger.definitions);
        }
    }

    // Remove the attr definitions
    for (var i = 0; i < attrs.length; i++) {
        delete swagger.definitions[attrs[i]];
    }

    return swagger;
}

function inlineAttrRef(obj, attrRefs, attrs, allDefs) {
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (var j = 0; j < len; j++) {
            // recurse array element
            inlineAttrRef(obj[j], attrRefs, attrs, allDefs);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == '$ref') {
                    var ref = obj[key];
                    var i = attrRefs.indexOf(ref);
                    if (i != -1) {
                        var ncName = attrs[i];
                        delete obj[key];
                        u.extendObject(obj, allDefs[ncName], true);
                        return;
                    }
                } else {
                    // recurse
                    inlineAttrRef(obj[key], attrRefs, attrs, allDefs);
                }
            }
        }
    }
}

/**
* Walk all of the defaults and adjust values if necessary.
* If the type is boolean, the default must be true or false
*/
function adjustDefaults(definitions, obj) {
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (var j = 0; j < len; j++) {
            // recurse array element
            adjustDefaults(definitions, obj[j]);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == 'default') {

                    // Get the type or ref'd type
                    var type = obj.type;
                    if (obj['$ref']) {
                        type = definitions[getDefNameFromRef(obj['$ref'])].type;
                    }

                    // If boolean, adjust the value if necessary
                    if (type == 'boolean') {
                        var value = obj.default;
                        if (value == 1) {
                            obj.default = true;
                        } else if (value == 0) {
                            obj.default = false;
                        }
                    }
                }
                adjustDefaults(definitions, obj[key]);
            }
        }
    }
}

/**
 * Remove unreferenced definitions
 */
function removeUnreferencedDefinitions(swagger, keepRootElements) {
    let keep = {};

    // Pre-populate keep map
    let map = {
        refs: {},
        nullableRefs: {},
        nonNullableRefs: {}
    };
    findRefs(swagger.paths, map);

    for (let ncName in swagger.definitions) {
        let def = swagger.definitions[ncName];
        if (ncName === 'Security') {
            keep[ncName] = {};
        } else if (ncName.endsWith('_Header')) {  // Extra Implicit Header added by schema
            keep[ncName] = {};
        } else if (ncName === dictionary.RESERVED_DEF) {
            // Only keep if no apic messages attached to it
            if (swagger.definitions[ncName].description) {
                keep[ncName] = { traversed: true };
            }
        } else if (map.refs['#/definitions/' + ncName]) {
            keep[ncName] = {};
        } else if (keepRootElements && def.xml && def.xml.name) {
            keep[ncName] = {};
        }
    }

    // Walk the keep map and add new references
    let repeat = true;
    while (repeat) {
        repeat = false;
        for (let ncName in keep) {
            if (!keep[ncName].traversed) {
                repeat = true;
                keep[ncName].traversed = true;
                let def = swagger.definitions[ncName];

                // Find the references within this definition
                let map = {
                    refs: {},
                    nullableRefs: {},
                    nonNullableRefs: {}
                };
                findRefs(def, map);

                // Walk the references and add them to the keep map
                for (let ref in map.refs) {
                    let ncName2 = getDefNameFromRef(ref);
                    let def2 = swagger.definitions[ncName2];
                    let refObj = map.refs[ref];
                    if ((refObj.count - refObj.allOfCount) > 0) {
                        // strong reference
                        keep[ncName2] = keep[ncName2] || {};

                        // Add the definitions that extend this definition (for polymorphism)
                        if (def2['x-ibm-discriminator'] && !keep[ncName2].calcPoly) {
                            keep[ncName2].calcPoly = true;
                            let extList = getExtensions(ref, swagger);
                            for (let i = 0; i < extList.length; i++) {
                                keep[extList[i]] = keep[extList[i]] || {};
                                keep[extList[i]].calcPoly = true;
                            }
                        }
                    } else {
                        // only allOf reference
                        keep[ncName2] = keep[ncName2] || {};
                    }
                }

                // Ugh, not sure if the map runtime has a dependency on the x-xsi-type-uniquename
                // being an actual definition.
                // We might be able to get rid of this code if we can verify what the map runtime
                // is doing with unique name.
                // We do know that the unique name is only used for polymorphism cases, so
                // only add the reference if a base (i.e. discriminator) or extension (i.e. allOf)
                let unique = def['x-xsi-type-uniquename'];
                if (unique && swagger.definitions[unique]) {
                    // treat as allOf only reference
                    if (def['x-ibm-discriminator'] || def.allOf) {
                        keep[unique] = keep[unique] || {};
                    }
                }
            }
        }
    }

    for (let ncName in swagger.definitions) {
        if (!keep[ncName]) {
            delete swagger.definitions[ncName];
        }
    }
}

function getExtensions(baseRef, swagger, list) {
    list = list || [];
    for (let ncName in swagger.definitions) {
        let def = swagger.definitions[ncName];
        if (def.allOf && def.allOf.length > 0 && def.allOf[0].$ref === baseRef) {
            list.push(ncName);
            if (def['x-ibm-discriminator']) {
                list = list.concat(getExtensions('#/definitions/' + ncName, swagger, []));
            }
        }
    }
    return list;
}

/**
* @return map popluated with refs, nullableRefs and nonNullableRefs
*/
function findRefs(obj, map, isAllOf, removeNullable) {
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (var j = 0; j < len; j++) {
            // recurse array element
            findRefs(obj[j], map, isAllOf, removeNullable);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == '$ref') {
                    var ref = obj[key];
                    map.refs[ref] = map.refs[ref] || { count: 0, allOfCount: 0 };
                    map.refs[ref].count += 1;
                    if (isAllOf) {
                        map.refs[ref].allOfCount += 1;
                    }
                    if (!isAllOf) {
                        let defName = getDefNameFromRef(ref);
                        if (obj['x-nullable']) {
                            if (!map.nullableRefs[defName]) {
                                map.nullableRefs[defName] = [];
                            }
                            map.nullableRefs[defName].push(obj);
                            if (removeNullable) {
                                delete obj['x-nullable'];
                            }
                        } else {
                            map.nonNullableRefs[defName] = true;
                        }
                    }
                } else {
                    // recurse
                    findRefs(obj[key], map, key == 'allOf', removeNullable);
                }
            }
        }
    }
}

/**
* Detect if nillable=true and nillable=false is needed for the same type.
* In such cases, the definition is duplicated and the refs are corrected.
*/
function fixupForNilAndNonNil(definitions) {

    let map = {
        refs: {},
        nullableRefs: {},
        nonNullableRefs: {}
    };

    findRefs(definitions, map, false, true);


    // add nullable tag to referenced types
    for (let nullableDefName in map.nullableRefs) {
        if (map.nonNullableRefs[nullableDefName]) {
            // type has been referenced as nullable and not-nullable - must resolve by
            // cloning the type and patching up references
            let nullableDefNameName = nullableDefName + '_nil';
            let clonedDef = u.deepClone(definitions[nullableDefName]);
            clonedDef['x-nullable'] = true;
            definitions[nullableDefNameName] = clonedDef;
            let clonedRef = '#/definitions/' + nullableDefNameName;
            let nullProps = map.nullableRefs[nullableDefName];
            let cloneLen = nullProps.length;
            for (let ad = 0; ad < cloneLen; ad++) {
                let nullProp = nullProps[ad];
                nullProp['$ref'] = clonedRef;
            } // end for
        } else {
            definitions[nullableDefName]['x-nullable'] = true;
        }
    }
}

/**
* Remove redundant xml objects from swagger
*/
function optimizeNamespaces(swagger) {
    // Pros:
    //   If an xml object is the same as its ancestor it is not needed.
    //   Removing redundant xml objects can susbstantially shrink the size of the api.
    //
    // Cons:
    //   Namespaces are one of the most confusing and error prone parts of SOAP/schema.
    //   Removing xml objects makes the api more difficult to read, and *could* cause
    //   problems in the subsequent phases of api connect.
    //
    // Solution:
    //   Remove the redundant xml.prefix if:
    //     a) No namespace
    //     b) This is a leaf (string, number, etc) without any properties
    //   Remove the redundant xml:
    //     a) This is a leaf (string, number, etc) without any properties -AND-
    //     b) ALL ancestors have the same xml namespaces. -AND-
    //     c) Ignore xml in an allOf and reboot the ancestor list.
    //     d) This is not an attribute
    //
    //   This means that namespaces will be removed in the common and safe cases.
    //   This means that namespaces will be preserved for the cases involving lots of namespace switching.
    //   Cornercase problems in the runtime (i.e. allOfs) will be avoided.
    //
    return _optimizeNamespaces(swagger, [], false);
}

function _optimizeNamespaces(obj, nsList, isAllOf) {
    if (obj === null) {
        return null;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    var child, cloned;
    if (obj instanceof Array) {
        child = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            if (isAllOf) {
                cloned = _optimizeNamespaces(obj[i], [], true);
            } else {
                cloned = _optimizeNamespaces(obj[i], nsList, false);
            }
            child.push(cloned);
        } // end for
    } else {
        child = {};
        // Push the xml
        if (obj.xml && !isAllOf) {
            let xml = u.deepClone(obj.xml);
            let len = nsList.length;
            xml.same = len === 0 ||
              (nsList[len - 1].same &&
               nsList[len - 1].prefix === xml.prefix &&
               xml.namespace !== 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd' &&
               nsList[len - 1].namespace === xml.namespace);
            nsList.push(xml);
        }
        // Recurse
        for (var key in obj) {
            cloned = _optimizeNamespaces(obj[key], nsList, key === 'allOf');
            child[key] = cloned;
        }
        // Pop and process the xml
        if (obj.xml && !isAllOf) {
            let xml = nsList.pop();
            // Remove the prefix if the namespace is ''
            if (xml.namespace === '' && xml.prefix === '') {
                if (!obj.property && obj.type && obj.type != 'object' && obj.type != 'array') {
                    delete child.xml.prefix; // prefix is not needed if no namespace
                }
            }
            // We can remove the whole xml if all xml ancestors are the same and this is a leaf
            if (xml.same && !xml.attribute && nsList.length > 0) {
                if (!obj.property && obj.type && obj.type != 'object' && obj.type != 'array') {
                    delete child.xml;
                }
            }
        }
    }
    return child;
}


/**
* Get NCName from a $ref field*
*/
function getDefNameFromRef(ref) {
    return ref.substring(ref.lastIndexOf('/') + 1);
}

exports.adjustDefaults = adjustDefaults;
exports.duplicatePolyHierarchy = duplicatePolyHierarchy;
exports.fixupForNilAndNonNil = fixupForNilAndNonNil;
exports.inlineSwaggerAttributes = inlineSwaggerAttributes;
exports.optimizeNamespaces = optimizeNamespaces;
exports.removeUnreferencedDefinitions = removeUnreferencedDefinitions;
