/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Utility functions to generate SwaggerDefinition the apiconnect-wsdl parser
**/
const u = require('../lib/utils.js');
const dictionary = require('../lib/dictionary.js');

var assert = require('assert');
var util = require('util');

// Context of referencing element or attribute
var UNQUALNS = 'UNQUALIFIED_NAME_SPACE';

// Child descriptions place on parent or on Child
var CHILD_DESCRIPTION_PLACED_ON_PARENT = false;

/**
*  The dictionary contains the node.soap schema for each ns name.
*  For example, dict.dictEntry['foo_ns1'].schema is the schema for the foo element or type
*  in ns1.
*
*  An ns name is referenced by other types and elements.  The referencing context
*  determines the namespace qualification (or no namespace qualification..aka unqualified) of
*  the referencing type.  (And the defining context defines the namespace qualification of the inner types, extensions, etc).
*  Thus if foo_ns1 is referenced in a qualified schema, ns2, then the code needs to generate a
*  swagger definition unique for that context  (foo_ns1_ns2).  Or if foo_ns1 is referenced in an unqualified schema,
*  then the code needs to generate a foo_ns1_unqual definition.  (Note that there are some optimizations to
*  help reduce the number of definitions...thus we might generate foo_ns1 instead of foo_ns_unqual).
*
*  Summary: The swagger definition is the product of a (nsName, referencingContext).
*/

/**
* Add a reference to the reference map.
* The dictionary item being referenced is nsName and the referencingContext is the information about the reference
* @param refMap is the reference map
* @param nsName is target name
* @param referencingContext
*/
function addReference(refMap, nsName, referencingContext) {
    if (!refMap[nsName]) {
        refMap[nsName] = {
            offset: 0,
            referencingContexts: [ referencingContext ]
        };
    } else {
        // Add the referencing context if not found
        let found = false;
        let len = refMap[nsName].referencingContexts.length;
        for (let i = 0; i < len; i++) {
            if (referencingContext.ns == refMap[nsName].referencingContexts[i].ns &&
                referencingContext.attribute == refMap[nsName].referencingContexts[i].attribute) {
                if (referencingContext.xmlName) {
                    refMap[nsName].referencingContexts[i].xmlName = referencingContext.xmlName;
                }
                found = true;
                break;
            }
        }
        if (!found) {
            refMap[nsName].referencingContexts.push(referencingContext);
        }
    }
}

/**
* @return the definition name for a (nsName + referencingContext)
*/
function getDefinitionName(nsName, referencingContext, namespaces) {
    let definitionName = nsName;
    let contextSuffix = '';

    if (referencingContext && referencingContext.attribute) {
        contextSuffix += '_attr';
    }
    if (referencingContext && referencingContext.ns) {
        if (referencingContext.ns == UNQUALNS) {
            contextSuffix += '_unqual';
        } else {
            contextSuffix += '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }
    }

    if (referencingContext && referencingContext.xmlName) {
        contextSuffix += '_of_' + referencingContext.xmlName;
    }

    definitionName = (contextSuffix == '') ? definitionName : definitionName + contextSuffix;

    return definitionName;
}

/*
* Create the Swagger Definitions for the referennces in refMap.
*/
function generateSwaggerDefinitions(definitions, refMap, dict, namespaces, oldRefMap) {

    // Create a clone of the refMap.
    // New references will be added to the cloned refMap by the generateSwaggerDefinition function
    let cloneRefMap = u.extendObject({}, refMap);

    // Compare the refMap to the old refMap and create a list
    // of the name value pairs that need to be processed.
    oldRefMap = oldRefMap || {};
    let refList = u.disjointKeysToArray(refMap, oldRefMap);

    let len = refList.length;
    for (var i = 0; i < len; i++) {
        // The refList has a name (which is the nsName)
        // and a value (which is the referencingContext array and an offset)
        // The offset indicates which referencingContexts have already been processed.
        // For example name (foo_ns) might have 1 referencingContext, but additional
        // referencingContexts are discovered during this recursive generation code.
        // The offset is the indicator of which referencingContexts have been processed
        // and which have not.
        let nameValue = refList[i];
        let nsName = nameValue.name;
        let value = nameValue.value;

        let rcLen = value.referencingContexts.length;
        for (var j = value.offset; j < rcLen; j++) {
            generateSwaggerDefinition(nsName, value.referencingContexts[j], definitions, cloneRefMap, dict, namespaces);
        } // end for
        // track how far we are through the array
        refMap[nsName].offset = rcLen;
    }

    // Find the newly added references and generate those swagger definitions.
    if (len > 0) {
        generateSwaggerDefinitions(definitions, cloneRefMap, dict, namespaces, refMap);
    }
}

/**
* Create a Swagger Definitions for the nsName + referencingContext
*/
function generateSwaggerDefinition(nsName, referencingContext, definitions, refMap, dict, namespaces) {
    var definition;
    var definitionName;
    var updated = false;
    let uniqueSuffix = '';


    // Type is the name of the root element, root attribute or root type
    // A root attribute will have attribute appended to the end
    // Example:
    //    Stock_s1
    //    Stock_s1_attr
    //
    // The referencing context provides additional information.
    // For example, the reference to a (simple) type might be from an attribute
    // For example, the reference to the type might be from a different or unqualified namespace.
    // The referencing information causes a new definition to be created.
    // Example:
    //     Stock_s1_unqual  means that the Stock_s1 type is referenced in an unqualified context
    //     Stock_s1_attr_s2 means that the Stock_s1 type is referenced by an attribute in a namespace corresponding to s2
    //
    let dictEntry = dict.dictEntry[nsName];
    if (dictEntry) {

        // Create the definition name from the nsName and the referencingContext information
        definitionName = getDefinitionName(nsName, referencingContext, namespaces);
        if (referencingContext.ns) {
            uniqueSuffix += (referencingContext.ns == UNQUALNS) ? '_unqual' : '_' + u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }

        // Create the definition
        if (!definitions[definitionName]) {
            if (!referencingContext.ns) {
                // If the name is used as an element, then set the reference to the nanespace of the element.
                // otherwise set it to the tns if qualified or UNQUAL if not qualified
                if (dict.elementNS[nsName]) {
                    referencingContext.ns = dict.elementNS[nsName].ns;
                } else {
                    referencingContext.ns = dictEntry.qualified ? dictEntry.tns : UNQUALNS;
                }
            }

            definition = generateSwaggerXSO(dictEntry, dict, refMap, namespaces, referencingContext);
            definitions[definitionName] = definition;
            updated = true;
        }
    }

    // Add xmlname and attribute
    if (updated && definition.xml) {
        if (referencingContext && referencingContext.xmlName) {
            definition.xml.name = referencingContext.xmlName;
        }
        if (referencingContext && referencingContext.attribute) {
            definition.xml.attribute = true;
        }
    }

    // Generate xsi type for types/elements but not for attributes
    if (updated && dictEntry && dictEntry.schema &&
       !dictEntry.isAttribute && !(referencingContext && referencingContext.attribute)) {
        if (dict.originalNames[nsName]) {
            // XSI type is the original type name...which is either the name from the original schema or the original name.
            if (dictEntry.suppressXSIType) {
                // (If the schema has suppressXSIType, then this must be a root element that was not overwritten with its type schema:
                //   <element name="example" type="string" />
                //  in such cases we don't need an x-xsi-type...if we did it must be created from the type= value)
            } else if (dictEntry.schema['undefined'] && dictEntry.schema['undefined'].name) {
                // (If the original type is an element, then the name on the schema is its type name due to the way schema object is replicated)
                definition['x-xsi-type'] = dictEntry.schema['undefined'].name;
            } else if (dict.originalNames[nsName]) {
                definition['x-xsi-type'] = dict.originalNames[nsName].name;
            }
        }
        if (definition['x-xsi-type']) {
            // If x-xsi-type is set, then check for the following case:
            //  <element name="foo" type="abstractbase" />
            //
            // In such cases, abstractbase_ns1 will be marked with an x-ibm-descriminator, but we
            // also need to make sure that foo_ns1 is marked. Use the linkup field to get the type
            // and then check subTypes to see if the type is a base.
            if (dictEntry &&
                dictEntry.schema['undefined'] &&
                dictEntry.schema['undefined'].linkup) {
                var linkup = dictEntry.schema['undefined'].linkup;
                if (dict.subTypes[linkup]) {
                    definition['x-ibm-discriminator'] = true;
                }
            }

            // In addition, also set the x-xsi-type-xml object from the location of the original type
            if (dictEntry && dictEntry.tns) {
                definition['x-xsi-type-xml'] = {
                    namespace: dictEntry.tns
                };
                definition['x-xsi-type-xml'].prefix = u.getPrefixForNamespace(dictEntry.tns, namespaces);
                definition['x-xsi-type-uniquename'] =  definition['x-xsi-type'] + '_' + definition['x-xsi-type-xml'].prefix + uniqueSuffix;
            }
        }
    }
}


// Generate a Open API (Swagger) XML Schema Object (aka XSO)
// An XML Schema Object is defined by Open API as the represntation of an XML construct.
// Each definition in the definitions section is an XML Schema Object.
// And definitions may have embedded, inlined XMLSchma Object.
// The generateSwaggerXSO is the common code for all XSO generation
function generateSwaggerXSO(dictEntry, dict, refMap, namespaces, referencingContext) {
    // Check to see if a predefined schema is provided, which means that it has a predefined definition
    if (dictEntry && dictEntry.schemaType == 'predefined') {

        if (dictEntry.schema.annotation) {
            if (dictEntry.schema.annotation.documentation) {
                dictEntry.definition.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation);
            }
        }
        return dictEntry.definition;
    }

    var ret = {
        xml: {}
    };
    var contextFlags = {};
    var restriction, listType, value, enums, i, enm, swaggerType, baseType, extension, props, previousXML;
    if (referencingContext && referencingContext.ns) {
        if (referencingContext.ns == UNQUALNS) {
            ret.xml.namespace = '';
            ret.xml.prefix = '';
        } else {
            ret.xml.namespace = referencingContext.ns;
            ret.xml.prefix = u.getPrefixForNamespace(referencingContext.ns, namespaces);
        }
    } else {
        ret.xml.namespace = dictEntry.tns;
        ret.xml.prefix = u.getPrefixForNamespace(dictEntry.tns, namespaces);
    }

    // The construct mixed=true is not supported for the general case,
    // but if there are no elements in the complexType, then we map the mixed content to a string.
    var mixedContentMappedToString = false;
    if (dictEntry.schemaType === 'complex' && dictEntry.schema['undefined'] && dictEntry.schema['undefined'].mixed === 'true') {
        if (dictEntry.schema.sequence ||
        dictEntry.schema.all ||
        dictEntry.schema.choice ||
        dictEntry.schema.group ||
        dictEntry.schema.list ||
        dictEntry.schema.complexContent ||
        dictEntry.schema.simpleContent ||
        dictEntry.schema.union ||
        dictEntry.schema.extension ||
        dictEntry.schema.restriction) {
            dictionary.annotateWithParserMessage(dictEntry.schema, 'The mixed=true attribute is ignored.');
        } else {
            mixedContentMappedToString = true;
        }
    }

    if (dictEntry.isAttribute) {
    // Schema is a root attribute
        ret.xml.attribute = true;
    }

    // If anyType is detected, then quick exit
    if (dictEntry && dictEntry.schemaType === 'anyType') {
        if (dictEntry.schema && dictEntry.schema.annotation) {
            if (dictEntry.schema.annotation.documentation) {
                ret.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation);
            }
        }
        return ret; // An anyType will have no type
    }

    // Alert if multiple constructs defined
    let countConstructs = 0;
    if (dictEntry.schema.sequence) {
        countConstructs += Array.isArray(dictEntry.schema.sequence) ? dictEntry.schema.sequence.length : 1;
    }
    if (dictEntry.schema.all) {
        countConstructs += Array.isArray(dictEntry.schema.all) ? dictEntry.schema.all.length : 1;
    }
    if (dictEntry.schema.choice) {
        countConstructs += Array.isArray(dictEntry.schema.choice) ? dictEntry.schema.choice.length : 1;
    }
    if (dictEntry.schema.group) {
        countConstructs += Array.isArray(dictEntry.schema.group) ? dictEntry.schema.group.length : 1;
    }
    if (countConstructs > 1) {
        dictionary.annotateWithParserMessage(dictEntry.schema, 'A complexType may contain only one sequence, one choice, one group, or one all. Please correct the schema.');
    }

    ret.type = 'object';
    ret.properties = {};
    if (dictEntry.schema.sequence) {
        handleSequenceRef(dictEntry.schema.sequence, dictEntry, dict, refMap, ret,
      namespaces, dictEntry.tns, contextFlags);
    } else if (dictEntry.schema.all) {
        handleAllRef(dictEntry.schema.all, dictEntry, dict, refMap, ret,
      namespaces, dictEntry.tns, contextFlags);
    } else if (dictEntry.schema.choice) {
        handleChoiceRef(dictEntry.schema.choice, dictEntry, dict, refMap, ret,
      namespaces, dictEntry.tns, contextFlags);
    } else if (dictEntry.schema.group) {
        handleGroupRef(dictEntry.schema.group, dictEntry, dict, refMap, ret,
      namespaces, dictEntry.tns, contextFlags);
    } else if (dictEntry.schema.list) {
        // xsd:list is a whitespace delimited string of the types defined in the itemType attribute.
        // This is an uncommon usage, and the best approach is to map to a string
        ret.type = 'string';
        delete ret.properties;
    } else if (dictEntry.schema.restriction && dictEntry.schemaType == 'simple') {
        restriction = dictEntry.schema.restriction;
        if (!restriction['undefined']) {
            // might be nested restriction
            if (restriction.simpleType && restriction.simpleType.restriction) {
                restriction = restriction.simpleType.restriction;
            }
        }
        if (restriction && restriction['undefined']) {
            var isXSD = dictionary.isXSDType(restriction['undefined'].base, namespaces);
            listType = dictionary.getNsName(restriction['undefined'].base);
            if (listType) {
                ret.type = listType;
            } else {
                ret.type = 'string';
            }
            delete ret.properties;
            if (restriction.pattern) {
                var patterns = u.makeSureItsAnArray(restriction.pattern);
                var patLen = patterns.length;
                if (patLen == 1) {
                    ret.pattern = patterns[0]['undefined'].value;
                } else {
                    // in odd cases where more than one pattern is supplied, we must combine into one regex
                    ret.pattern = '(' + patterns[0]['undefined'].value + ')';
                    for (i = 1; i < patLen; i++) {
                        var pat = patterns[i];
                        ret.pattern += '|(' + pat['undefined'].value + ')';
                    } // end for
                }
            }
            if (restriction.whiteSpace) {
                if (typeof restriction.whiteSpace['undefined'].value !== 'undefined') {
                    ret['x-ibm-whiteSpace'] = restriction.whiteSpace['undefined'].value;
                }
            }
            if (restriction.fractionDigits) {
                if (typeof restriction.fractionDigits['undefined'].value !== 'undefined') {
                    value = parseInt(restriction.fractionDigits['undefined'].value);
                    ret['x-ibm-fractionDigits'] = value;
                }
            }
            if (restriction.totalDigits) {
                if (typeof restriction.totalDigits['undefined'].value !== 'undefined') {
                    value = parseInt(restriction.totalDigits['undefined'].value);
                    ret['x-ibm-totalDigits'] = value;
                }
            }
            if (restriction.maxLength) {
                if (typeof restriction.maxLength['undefined'].value !== 'undefined') {
                    value = parseInt(restriction.maxLength['undefined'].value);
                    ret.maxLength = value;
                }
            }
            if (restriction.minLength) {
                if (typeof restriction.minLength['undefined'].value !== 'undefined') {
                    value = parseInt(restriction.minLength['undefined'].value);
                    ret.minLength = value;
                }
            }
            if (restriction['length']) {
                if (typeof restriction['length']['undefined'].value !== 'undefined') {
                    value = parseInt(restriction['length']['undefined'].value);
                    ret.minLength = value;
                    ret.maxLength = value;
                }
            }
            if (restriction.enumeration) {
                ret.type = 'string'; // enums can only be string type
                enums = u.makeSureItsAnArray(restriction.enumeration);
                ret['enum'] = [];
                var enumsLen = enums.length;
                for (i = 0; i < enumsLen; i++) {
                    enm = enums[i];
                    ret['enum'].push(enm['undefined'].value);
                } // end for
            } else if (!isXSD && dict.dictEntry[ret.type]) {
                if (dictEntry.schema['undefined'] && dictEntry.schema['undefined'].name == ret.type) {
                    // stop hard cycles due to weird schema name clashes
                    swaggerType = mapXSDTypeToSwagger(ret.type);
                    u.extendObject(ret, swaggerType);
                } else {
                    addReference(refMap, ret.type, {});
                    if (isPrimitiveType(dict.dictEntry[ret.type], namespaces)) {
                        var primitiveRef = generateSwaggerXSO(dict.dictEntry[ret.type], dict, refMap, namespaces);
                        delete ret.type;
                        delete primitiveRef.xml; // existing obj will already have its namespace
                        u.extendObject(ret, primitiveRef);
                    } else {
                        var ref = '#/definitions/' + ret.type;
                        delete ret.type;
                        delete ret.xml;
                        ret['$ref'] = ref;
                    }
                }
            } else {
                swaggerType = mapXSDTypeToSwagger(u.stripNamespace(restriction['undefined'].base));
                u.extendObject(ret, swaggerType);
            }
            // map min and max after we've put the default limits in per type so that the schema can override
            if (restriction.minInclusive) {
                if (ret.type != 'integer' || ret.type != 'number') {
                    ret.minimum = u.parseToPrimitive(restriction.minInclusive['undefined'].value);
                } else if (ret.type == 'number' && (ret.format == 'float' || ret.format == 'double')) {
                    ret.minimum = parseFloat(restriction.minInclusive['undefined'].value);
                } else {
                    ret.minimum = parseInt(restriction.minInclusive['undefined'].value);
                }
            }
            if (restriction.minExclusive) {
                if (ret.type != 'integer' || ret.type != 'number') {
                    ret.minimum = u.parseToPrimitive(restriction.minExclusive['undefined'].value);
                } else if (ret.type == 'number' && (ret.format == 'float' || ret.format == 'double')) {
                    ret.minimum = parseFloat(restriction.minExclusive['undefined'].value);
                } else {
                    ret.minimum = parseInt(restriction.minExclusive['undefined'].value);
                }
                ret.exclusiveMinimum = true;
            }
            if (restriction.maxInclusive) {
                if (ret.type != 'integer' || ret.type != 'number') {
                    ret.maximum = u.parseToPrimitive(restriction.maxInclusive['undefined'].value);
                } else if (ret.type == 'number' && (ret.format == 'float' || ret.format == 'double')) {
                    ret.maximum = parseFloat(restriction.maxInclusive['undefined'].value);
                } else {
                    ret.maximum = parseInt(restriction.maxInclusive['undefined'].value);
                }
            }
            if (restriction.maxExclusive) {
                if (ret.type != 'integer' || ret.type != 'number') {
                    ret.maximum = u.parseToPrimitive(restriction.maxExclusive['undefined'].value);
                } else if (ret.type == 'number' && (ret.format == 'float' || ret.format == 'double')) {
                    ret.maximum = parseFloat(restriction.maxExclusive['undefined'].value);
                } else {
                    ret.maximum = parseInt(restriction.maxExclusive['undefined'].value);
                }
                ret.exclusiveMaximum = true;
            }
        } else {
            throw new Error('Missing base type for restriction');
        }
    } else if (dictEntry.schema.complexContent) {
        // handle other types of content
        restriction = dictEntry.schema.complexContent.restriction;
        if (restriction) {
            baseType = u.stripNamespace(restriction['undefined'].base);
            if (baseType) {
                baseType = baseType.toLowerCase();
                if (baseType == 'array') {
                    dictionary.annotateWithParserMessage(dictEntry.schema, 'A restriction of a soap-enc array is not fully supported.');
                    // deal with array types
                    var attribute = restriction.attribute;
                    if (attribute) {
                        for (var attr in attribute['undefined']) {
                            var attrName = u.stripNamespace(attr).toLowerCase();
                            if (attrName == 'arraytype') {
                                var rawArrayType = attribute['undefined'][attr];
                                if (rawArrayType.indexOf('[]', rawArrayType.length - 2) != -1) {
                                    rawArrayType = rawArrayType.substr(0, rawArrayType.length - 2);
                                }
                                var arrayType = dictionary.getNsName(rawArrayType);
                                ret.type = 'array';
                                delete ret.properties;
                                ret.items = {};
                                if (dict.dictEntry[arrayType]) {
                                    // reference is to another type - recurse
                                    // only include if we've not already seen it as a parent type
                                    addReference(refMap, arrayType, {});
                                    ret.items['$ref'] = '#/definitions/' + arrayType;
                                } else {
                                    swaggerType = mapXSDTypeToSwagger(u.stripNamespace(rawArrayType));
                                    u.extendObject(ret.items, swaggerType);
                                }
                                break;
                            }
                        } // end for
                    }
                } else {
                    // Restriction of complexContent is rare
                    // Add the elements in the embedded sequence.
                    // The base is read, and used to set up the xml information
                    baseType = dictionary.bestMatch(restriction['undefined'].base, dictEntry, dict, namespaces);
                    if (!baseType || !dict.dictEntry[baseType] || !dict.dictEntry[baseType].schema) {
                        dictionary.annotateWithParserMessage(dictEntry.schema, 'The base ' + restriction['undefined'].base +
                          'of restriction element cannot be found.');
                    } else if (isSGAC(restriction)) {
                        var baseSchema = dict.dictEntry[baseType];
                        // use an allOf so that we can separate the xml stanza
                        // of the caller from the xml of the restriction base
                        previousXML = ret.xml;
                        ret = {
                            xml: previousXML,
                            allOf: []
                        };
                        contextFlags.inAllOf = true;

                        // Create properties for the restricted sequence
                        props = {
                            xml: {},
                            type: 'object',
                            properties: {}
                        };

                        // For a restriction, the referencing context is not this schema it is the
                        // the schema of the base type.
                        if (baseSchema.qualified) {
                            props.xml.namespace = baseSchema.tns;  // Changed to restriction base
                            props.xml.prefix = u.getPrefixForNamespace(baseSchema.tns, namespaces);
                        } else {
                            props.xml.namespace = '';
                            props.xml.prefix = '';
                        }
                        ret.allOf.push(props);
                        handleSGACRef(restriction, baseSchema, dict, refMap, props, namespaces, baseSchema.tns, contextFlags);

                        // Map Policy may require a second allOf
                        props = {
                            xml: {
                                namespace: '',
                                prefix: ''
                            },
                            type: 'object',
                            properties: {}
                        };
                        ret.allOf.push(props);
                    }
                }
            }
        }
        // look for extension of existing type
        extension = dictEntry.schema.complexContent.extension;
        if (extension) {
            baseType = dictionary.bestMatch(extension['undefined'].base, dictEntry, dict, namespaces);
            if (baseType) {
                if (dict.dictEntry[baseType]) {
                    addReference(refMap, baseType, {});
                    // use an allOf clause for extension types
                    previousXML = ret.xml;
                    ret = {
                        xml: previousXML,
                        allOf: []
                    };
                    contextFlags.inAllOf = true;
                    ret.allOf.push({
                        $ref: '#/definitions/' + baseType
                    });
                    if (isSGAC(extension)) {
                        props = {
                            xml: {},
                            type: 'object',
                            properties: {}
                        };
                        props.xml.namespace = previousXML.namespace;
                        props.xml.prefix = previousXML.prefix;
                        ret.allOf.push(props);
                        handleSGACRef(extension, dictEntry, dict, refMap, props, namespaces, dictEntry.tns, contextFlags);
                    } else {
                        // Assembly Map policy expects second allOf element
                        props = {
                            xml: {
                                namespace: '',
                                prefix: ''
                            },
                            type: 'object',
                            properties: {}
                        };
                        ret.allOf.push(props);
                    }
                }
            }
            // attributes can appear on extensions
            if (extension.attribute) {
                handleAttributeRef(extension.attribute, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
            }
            if (extension.attributeGroup) {
                handleAttributeGroupRef(extension.attributeGroup, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
            }
        }
    } else if (dictEntry.schema.simpleContent) {
        // look for extension of primitive type
        extension = dictEntry.schema.simpleContent.extension;
        if (extension) {
            baseType = dictionary.resolveNameInNamespace(extension['undefined'].base, dictEntry.xmlns, namespaces);
            if (baseType) {
                if (dict.dictEntry[baseType]) {
                    addReference(refMap, baseType, {});
                    // use an allOf clause for extension types
                    previousXML = ret.xml;
                    ret = {
                        xml: previousXML,
                        allOf: []
                    };
                    ret.allOf.push({
                        $ref: '#/definitions/' + baseType
                    });
                    contextFlags.inAllOf = true;
                    if (isSGAC(extension)) {
                        props = {
                            xml: {},
                            type: 'object',
                            properties: {}
                        };
                        props.xml.namespace = previousXML.namespace;
                        props.xml.prefix = previousXML.prefix;
                        ret.allOf.push(props);
                        handleSGACRef(extension, dictEntry, dict, refMap, props, namespaces, null, contextFlags);
                    } else {
                        // Assembly Map policy expects second allOf element
                        props = {
                            xml: {
                                namespace: '',
                                prefix: ''
                            },
                            type: 'object',
                            properties: {}
                        };
                        ret.allOf.push(props);
                    }
                } else {
                    var simpleType = mapXSDTypeToSwagger(u.stripNamespace(extension['undefined'].base));
                    u.extendObject(ret, simpleType);
                }
            }
            // attributes can appear on extensions
            if (extension.attribute) {
                handleAttributeRef(extension.attribute, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
            }
            if (extension.attributeGroup) {
                handleAttributeGroupRef(extension.attributeGroup, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
            }
        }
    } else if (dictEntry.schema && ('union' in dictEntry.schema)) {
        // A union will appear inside of a simpleType, map it to the generic built-in string
        ret.type = 'string';
    }

    // attributes can appear in addition to other entries
    if (dictEntry.schema.attribute) {
        handleAttributeRef(dictEntry.schema.attribute, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
    }
    if (dictEntry.schema.attributeGroup) {
        handleAttributeGroupRef(dictEntry.schema.attributeGroup, dictEntry, dict, refMap, ret, namespaces, dictEntry.tns);
    }

    if (mixedContentMappedToString) {
        // Put the attributes in an allOf and then add a string for the mixed content
        var currentRet = u.deepClone(ret);
        var currentXML = u.deepClone(ret.xml);
        ret = {
            xml: currentXML,
            allOf: [ currentRet,
                { type: 'string' }
            ]
        };
    }
    // Convert the annotations after processing the other elements because that processing may add additional annotations.
    if (dictEntry.schema.annotation) {
        // include annotation as description
        if (dictEntry.schema.annotation.documentation) {
            ret.description = u.cleanupDocumentation(dictEntry.schema.annotation.documentation);
        }
    }
    return ret;
}

/**
*  Called during XSO generation to process a sequence
*/
function handleSequenceRef(sequence, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags) {
    if ('any' in sequence) {
        ret.additionalProperties = true;
    }
    var items = [];
    var id = 0;
    var i;
    var order;

    /**
    * We want to process the element, choice, sequence, and group constructs in the
    * declared order so that the properties have the same order as the schema.
    * Put the constructs into an items map using the apicID key (which we added during preParse)
    */
    if (sequence.element) {
        var elements = u.deepClone(u.makeSureItsAnArray(sequence.element));
        for (i = 0; i < elements.length; i++) {
            if (elements[i]['undefined'].apicID) {
                order = parseInt(elements[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'element', order: order, value: [ elements[i] ] });
        }
    }

    if (sequence.choice) {
        var choices = u.deepClone(u.makeSureItsAnArray(sequence.choice));
        for (i = 0; i < choices.length; i++) {
            if (choices[i]['undefined'].apicID) {
                order = parseInt(choices[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'choice', order: order, value: [ choices[i] ] });
        }
    }

    if (sequence.group) {
        var groups = u.deepClone(u.makeSureItsAnArray(sequence.group));
        for (i = 0; i < groups.length; i++) {
            if (groups[i]['undefined'].apicID) {
                order = parseInt(groups[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'group', order: order, value: groups[i] });
        }
    }

    if (sequence.sequence) {
        var sequences = u.deepClone(u.makeSureItsAnArray(sequence.sequence));
        for (i = 0; i < sequences.length; i++) {
            if (sequences[i]['undefined'].apicID) {
                order = parseInt(sequences[i]['undefined'].apicID);
            } else {
                order = id++;
            }
            items.push({ type: 'sequence', order: order, value: sequences[i] });
        }
    }

    // Now sort the keys so that we process the constructs in the declared order
    items = items.sort(function(a, b) {
        return a.order - b.order;
    });

    // Process the constructs
    let len = items.length;
    for (var k = 0; k < len; k++) {
        if (items[k].type == 'element') {
            processElements(items[k].value, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags);
        } else if (items[k].type == 'choice') {
            var flatElements = [];
            flattenChoice(items[k].value, flatElements);
            processElements(flatElements, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags);
        } else if (items[k].type == 'group') {
            handleGroupRef(items[k].value, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags);
        } else if (items[k].type == 'sequence') {
            handleSequenceRef(items[k].value, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags);
        }
    }
}

/**
*  Called during XSO generation to process a choice
*/
function handleChoiceRef(choice, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags) {

    var elements = [];
    if (choice) {
        if ('any' in choice) {
            ret.additionalProperties = true;
        }
        // special case for any choices - we inline the element and add a warning description
        // as swagger cant deal with oneOf clauses
        flattenChoice(choice, elements);
    }
    processElements(elements, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
}

/**
*  Called during XSO generation to process an all
*/
function handleAllRef(all, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags) {
    var elements = [];
    if (all.element) {
        elements = u.deepClone(u.makeSureItsAnArray(all.element)); // clone to avoid updating this list by flattenChoice
    }
    if ('any' in all) {
        ret.additionalProperties = true;
    }
    if (all.choice) {
        // special case for any choices - we inline the element and add a warning description
        // as swagger cant deal with oneOf clauses
        flattenChoice(all.choice, elements);
    }
    // for an all condition we set the implied minOccurs value to 1 unless already switched off
    var required = true;
    if (all['undefined']) {
        // can have a minOccurs at the "all" level to switch the logic
        var minOccurs = all['undefined'].minOccurs;
        if (minOccurs === 0) {
            required = false;
        }
    }
    if (required) {
        var len = elements.length;
        for (var i = 0; i < len; i++) {
            var element = elements[i];
            // only set the required flag if no minimum already set
            if (typeof element['undefined'].minOccurs === 'undefined') {
                element['undefined'].minOccurs = 1;
            }
        } // end for
    }
    processElements(elements, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
    // look for nested sequences
    var sequences = [];
    if (all.sequence) {
        sequences = u.makeSureItsAnArray(all.sequence);
        var seqLen = sequences.length;
        for (var j = 0; j < seqLen; j++) {
            var seq = sequences[j];
            handleSequenceRef(seq, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
        } // end for
    }
}

/**
* @return true if sequence group all or choice
*/
function isSGAC(obj) {
    return obj && (obj.sequence || obj.group || obj.all || obj.choice);
}

/**
* handle sequence group all or choice
*/
function handleSGACRef(obj, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags) {
    if (obj.sequence) {
        handleSequenceRef(obj.sequence, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
    } else if (obj.group) {
        handleGroupRef(obj.group, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
    } else if (obj.all) {
        handleAllRef(obj.all, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
    } else if (obj.choice) {
        handleChoiceRef(obj.choice, dictEntry, dict, typesFound, ret, namespaces, tns, contextFlags);
    }
}

/**
*  Called during XSO generation to flatten the elements found in a choice
*/
function flattenChoice(inChoice, elements) {
    if (inChoice) {
        var choices = u.makeSureItsAnArray(inChoice);
        var cLen = choices.length;
        for (var i = 0; i < cLen; i++) {
            var choice = choices[i];
            if (choice.element) {
                var choiceElements = u.makeSureItsAnArray(choice.element);
                var chLen = choiceElements.length;
                for (var j = 0; j < chLen; j++) {
                    var choiceElement = choiceElements[j];
                    choiceElement['undefined'].fromChoice = true;
                    elements.push(choiceElement);
                } // end for
            }
            if (choice.sequence) {
                var sequences = u.makeSureItsAnArray(choice.sequence);
                var seqLen = sequences.length;
                for (var l = 0; l < seqLen; l++) {
                    var sequence = sequences[l];
                    if (sequence.element) {
                        var seqElements = u.makeSureItsAnArray(sequence.element);
                        var chsLen = seqElements.length;
                        for (var k = 0; k < chsLen; k++) {
                            var seqElement = seqElements[k];
                            seqElement['undefined'].fromChoice = true;
                            elements.push(seqElement);
                        } // end for
                    }
                    if (sequence.choice) {
                        flattenChoice(sequence.choice, elements);
                    }
                } // end for
            }
        } // end for
    }
}

/**
*  Called during XSO generation to process a group
*/
function handleGroupRef(group, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags) {
    if (group['undefined'].ref) {
        if (contextFlags) {
            contextFlags = u.deepClone(contextFlags); // ContextFlags are only propogated downwards
        } else {
            contextFlags = {};
        }
        var isXSD = dictionary.isXSDType(group['undefined'].ref, namespaces);
        var groupType = dictionary.resolveNameInNamespace(group['undefined'].ref, dictEntry.xmlns, namespaces, dictEntry.tns);
        if (!dict.groups[groupType]) {
            groupType = u.stripNamespace(group['undefined'].ref);
        }

        let minOccurs = getOccurrence(group['undefined'].minOccurs);
        let maxOccurs = getOccurrence(group['undefined'].maxOccurs);

        // Check for minOccurs/maxOccurs that is something other than the default
        // Note a value of -1 indicates 'unbounded'
        if (minOccurs != 1 || maxOccurs != 1) {
            if (contextFlags.groupMinOccurs == null || contextFlags.groupMinOccurs == undefined) {
                contextFlags.groupMinOccurs = minOccurs;
            } else {
                contextFlags.groupMinOccurs *= minOccurs;
            }

            if (contextFlags.groupMaxOccurs == null || contextFlags.groupMaxOccurs == undefined) {
                contextFlags.groupMaxOccurs = maxOccurs;
            } else if (contextFlags.groupMaxOccurs < 0 || maxOccurs < 0) {
                contextFlags.groupMaxOccurs = -1;
            } else {
                contextFlags.groupMaxOccurs *= maxOccurs;
            }
            if (contextFlags.groupNS) {
                contextFlags.groupNS.push(groupType);
            } else {
                contextFlags.groupNS = [ groupType ];
            }
        }

        if (!isXSD && dict.groups[groupType]) {
            // reference is to another group - process inline
            var groupRef = dict.groups[groupType].group;
            var elements = [];
            let countConstructs = 0;
            if (groupRef.choice) {
                countConstructs++;
                // special case for any choices - we inline the element
                // as swagger cant deal with oneOf clauses
                flattenChoice(groupRef.choice, elements);
            }
            processElements(elements, dict.groups[groupType], dict, refMap, ret, namespaces, dict.groups[groupType].tns, contextFlags);
            // look for nested sequences
            var sequences = [];
            if (groupRef.sequence) {
                sequences = u.makeSureItsAnArray(groupRef.sequence);
                var seqLen = sequences.length;
                for (var i = 0; i < seqLen; i++) {
                    countConstructs++;
                    var seq = sequences[i];
                    handleSequenceRef(seq, dict.groups[groupType], dict, refMap, ret, namespaces, dict.groups[groupType].tns, contextFlags);
                } // end for
            }
            // look for nested all
            var alls = [];
            if (groupRef.all) {
                alls = u.makeSureItsAnArray(groupRef.all);
                var allLen = alls.length;
                for (var j = 0; j < allLen; j++) {
                    countConstructs++;
                    var all = alls[j];
                    handleAllRef(all, dict.groups[groupType], dict, refMap, ret, namespaces, dict.groups[groupType].tns, contextFlags);
                } // end for
            }
            if (countConstructs > 1) {
                dictionary.annotateWithParserMessage(dictEntry.schema, 'A group may only contain one sequence, one choice, or one all.  Each is processed, but this not compliant with the schema specification.');
            }
        }
    } else {
        // I don't know if inlined groups without ref are legal.  The specification is silent on this issue.
        dictionary.annotateWithParserMessage(dictEntry.schema, 'The ref attribute is missing on a group.  The group is ignored');
    }
}

/**
*  Called during XSO generation to process an attributeGroup
*/
function handleAttributeGroupRef(inGroup, dictEntry, dict, refMap, ret, namespaces, tns) {
    var attrGroups = u.makeSureItsAnArray(inGroup);
    for (var i = 0; i < attrGroups.length; i++) {
        var attrGroup = attrGroups[i];
        var attrRef = attrGroup['undefined'].ref;
        if (attrRef) {
            var nsName = dictionary.getNsName(attrRef);
            if (dict.attrGroups[nsName]) {
                var tgtGroup = dict.attrGroups[nsName];
                if (tgtGroup.attrGroup.attribute) {
                    handleAttributeRef(tgtGroup.attrGroup.attribute, dictEntry, dict, refMap, ret, namespaces, tns);
                }
                if (tgtGroup.attrGroup.attributeGroup) {
                    handleAttributeGroupRef(tgtGroup.attrGroup.attributeGroup, dictEntry, dict, refMap, ret, namespaces, tns);
                }
            }
        }
    }
}

/**
*  Called during XSO generation to process an attribute reference
*/
function handleAttributeRef(inAttr, dictEntry, dict, refMap, ret, namespaces, tns) {
    var attributes = u.makeSureItsAnArray(inAttr);
    var len = attributes.length;
    var properties = ret.properties;
    var props = ret;
    if (len > 0) {
        if (ret.allOf) {
            props = {
                xml: {
                    namespace: ''
                },
                type: 'object',
                properties: {}
            };
            properties = props.properties;
            ret.allOf.push(props);
        }
    }
    for (var i = 0; i < len; i++) {
        var attribute = attributes[i];
        var qualifiedAttr = dictEntry.qualifiedAttr;
        if (attribute['undefined'].form) {
            qualifiedAttr = (attribute['undefined'].form == 'qualified');
        }
        var newProp = {
            xml: {
                namespace: '',
                attribute: true
            }
        };

        var name = attribute['undefined'].name;

        // There are four choices
        // 1. Attribute can be defined by a ref
        // 2. Attribute is a built-in type
        // 3. Attribute is defined inlineRet
        // 4. Attribute is defined by a non-built-in type

        var attrRef = attribute['undefined'].ref;
        var nsName = null;
        var isXSD = false;
        if (attrRef) {
            nsName = dictionary.bestMatch(attribute['undefined'].ref, dictEntry, dict, namespaces, true, true);
        } else if (attribute['undefined'].type) {
            nsName = dictionary.bestMatch(attribute['undefined'].type, dictEntry, dict, namespaces);
            isXSD = dictionary.isXSDType(attribute['undefined'].type, namespaces, dictEntry.xmlns);
        }
        if (attrRef) {
            // 1. Attribute ref
            name = u.stripNamespace(attrRef); // The name is defined by the ref
            if (dict.dictEntry[nsName]) {
                newProp = {
                    $ref: '#/definitions/' + nsName
                };
                addReference(refMap, nsName, {});
            }
        } else if (isXSD) {
            // 2. Attribute is a built-in type
            var swaggerType = mapXSDTypeToSwagger(u.stripNamespace(attribute['undefined'].type));
            newProp.type = swaggerType.type;
            if (qualifiedAttr) {
                if (tns) {
                    newProp.xml.namespace = tns;
                    newProp.xml.prefix = u.getPrefixForNamespace(tns, namespaces);
                }
            }
            u.extendObject(newProp, swaggerType);
        } else if (!nsName) {
            // 3. Attribute is defined inline
            newProp.type = 'string'; // Assume string
            if (attribute.simpleType) {
                var simpleSchema = {
                    tns: '',
                    schemaType: 'simple',
                    schema: attribute.simpleType,
                    xmlns: dictEntry.xmlns
                };
                var inlineRet = generateSwaggerXSO(simpleSchema, dict, refMap, namespaces);
                newProp.type = inlineRet.type;
                if (qualifiedAttr) {
                    if (tns) {
                        newProp.xml.namespace = tns;
                        newProp.xml.prefix = u.getPrefixForNamespace(tns, namespaces);
                    }
                }
                extendXSO(newProp, inlineRet);
            }
        } else {
            // 4. Attribute is defined by a type that is not a built-in
            // An attribute is referencing a simple type.  We need to generate a definition that is suitable for an attribute.
            if (dict.dictEntry[nsName]) {
                addReference(refMap, nsName, {});
                let referencingContext = {
                    ns: (qualifiedAttr) ? tns : UNQUALNS,
                    attribute: true
                };
                addReference(refMap, nsName, referencingContext);
                newProp = {
                    $ref: '#/definitions/' + getDefinitionName(nsName, referencingContext, namespaces)
                };
            }
        }

        // Add default if either default or fixed is specified.
        if ('default' in attribute['undefined']) {
            newProp.default = u.parseToPrimitive(attribute['undefined'].default);
        }
        if ('fixed' in attribute['undefined']) {
            newProp.default = u.parseToPrimitive(attribute['undefined'].fixed);
        }

        // If required, then add it to the required list
        // (Note we could add a default, but the mapper has code to pick a reasonable default for each type)
        if (attribute['undefined'].use == 'required') {
            if (!props.required) {
                props.required = [];
            }
            props.required = props.required.concat(name);
        }

        if (attribute.annotation) {
            // include annotation as description
            if (attribute.annotation.documentation) {
                var doc = u.cleanupDocumentation(attribute.annotation.documentation);
                if (attrRef && CHILD_DESCRIPTION_PLACED_ON_PARENT) {
                    // if the attr is a reference we cant use description at the element level
                    // move it up to the parent container
                    if (props.description) {
                        props.description += ';\n' + name + ': ' + doc;
                    } else {
                        props.description = name + ': ' + doc;
                    }
                } else if (newProp.description) {
                    newProp.description += ';\n' + doc;
                } else {
                    newProp.description = doc;
                }
            }
        }

        // If a collision and not allOf, create allOf
        if (!ret.allOf && (properties[name] || properties[name] === {})) {
            // Get existing information in ret and move to allOf
            var oldProps = u.deepClone(ret);
            if (ret.properties) {
                delete ret.properties;
            }
            if (ret.required) {
                delete ret.required;
            }
            if (ret.type) {
                delete ret.type;
            }
            if (ret.description) {
                delete ret.description;
            }
            ret.allOf = [];
            ret.allOf.push(oldProps);

            // Create a new properties map and add to allOf
            props = {
                xml: u.deepClone(ret.xml),
                type: 'object',
                properties: {}
            };
            ret.allOf.push(props);
            properties = props.properties;
            properties[name] = newProp;
        } else {
            // Add new prop to the properties map
            detectPropertyCollision(name, properties, attribute);
            properties[name] = newProp;
        }
    } // end for
}

/**
 * Process the child elements of a sequence, choice, all, etc.
 * @param elements is the list of schema elements
 * @param dictEntry is the referencing dictionary entry
 * @param ret is the swagger.definition containing child element (properties)
 * @param dict is the global "dictionary" object
 * @param refMap is the map of the references.  Any discovered references are added to the map
 * @param ret is the property on the defintion (i.e. where "$ref" is added)
 * @param namespaces is the namespace list
 * @param tns is the namespace of the referencing type
 * @param contextFlags additional context (i.e. within allof)
 */
function processElements(elements, dictEntry, dict, refMap, ret, namespaces, tns, contextFlags) {
    if (u.useAsserts) {
        assert(tns == null || typeof tns == 'string',
        'expected typeNamespace of string, not ' + util.inspect(tns));
    }
    if (elements.length > 0) {
        var required = [];
        var refType, rawRefType, lastSlash;
        var elemLen = elements.length;
        contextFlags = contextFlags ? contextFlags : {};

        // Determine if the schema is qualified or not qualified
        var schemaQualified = false;
        if (dictEntry && dictEntry.qualified) {
            schemaQualified = true;
        }
        for (var i = 0; i < elemLen; i++) {
            var element = elements[i];
            var elemName = element['undefined'].name;

            // Now determine if the child is qualified
            var childQualified = schemaQualified;
            var elemQualified = element['undefined'].form;
            if (elemQualified) {
                if (elemQualified == 'qualified') {
                    childQualified = true;
                } else if (elemQualified == 'unqualified') {
                    childQualified = false;
                }
            }
            var elemNillable = false;
            var elemNillableAttr = element['undefined'].nillable;
            if (elemNillableAttr && elemNillableAttr === 'true') {
                elemNillable = true;
            }
            var elemType = '';
            var isXSD = false;
            var isElemRef = false;
            if (elemName) {
                isXSD = dictionary.isXSDType(element['undefined'].type, namespaces, dictEntry.xmlns);
                elemType = dictionary.bestMatch(element['undefined'].type, dictEntry, dict, namespaces);
            } else {
                // might be a direct reference to another type
                if (element['undefined'].ref) {
                    elemType = dictionary.bestMatch(element['undefined'].ref, dictEntry, dict, namespaces, false, true);
                    elemName = u.stripNamespace(element['undefined'].ref);
                    isElemRef = true;
                }
            }
            var isReference = false;
            var propNames = [];
            propNames.push(elemName);

            if ('unique' in element) {
                dictionary.annotateWithParserMessage(element, 'The unique element is ignored.');
            }

            if (!isXSD && elemType && dict.dictEntry[elemType]) {
                // Flow to here indicates that the child element has a type or ref that
                // locates a type or element that is defined in a schema (but is not an xsd primitive).
                refType = dict.dictEntry[elemType];

                // In schema, it is legal to have a root element and root complexType/simpleType to have the same
                // NS name.   For example:
                // <element name="foo" type="foo" />
                // <completype name="foo" ....
                // In such case the definition foo_ns1 is generated for the element
                // and we need to generate a separate defintion if the type is referenced (i.e. foo_ns1_unqual)
                var refTypeElementCollision = !isElemRef && dict.elementNS[elemType];

                // The referenced definition will contain an xml that matches the refType's qualified setting.
                // If the referencing qualification (childQualified) is different, then we need to create a
                // a duplicate definition.
                // We also need to a duplicate defintion if both refrenced and referencing qualifications are qualified
                // but they are using different namespaces.
                // We only need to do this when the child element references a type (uses type attribute)
                // because element refeferences (uses ref attribute) will always use the referenced definitions xml.
                if (!isElemRef &&
                    ((refType.qualified != childQualified) ||
                     (refTypeElementCollision && !childQualified) ||
                     ((refType.qualified || refTypeElementCollision) && tns && refType.tns != tns))) {

                    // Check the special case that this is a simpleType, and then set up the property has the primitive
                    if (isPrimitiveType(refType, namespaces)) {
                        var primitiveRef = generateSwaggerXSO(refType, dict, refMap, namespaces);
                        // primitive types can be inlined directly
                        detectPropertyCollision(elemName, ret.properties, element);
                        ret.properties[elemName] = primitiveRef;
                        if (childQualified) {
                            ret.properties[elemName].xml = {
                                namespace: tns,
                                prefix: u.getPrefixForNamespace(tns, namespaces)
                            };
                        } else {
                            ret.properties[elemName].xml = {
                                namespace: '',
                                prefix: ''
                            };
                        }
                    } else {
                        // Add the referenced type to the list of found types and add the referencing namespace
                        var referencingNS = (childQualified) ? tns : UNQUALNS;
                        addReference(refMap, elemType, {});
                        addReference(refMap, elemType, {
                            ns: referencingNS
                        });

                        // Now indicate that we need a duplicate definition that will have the proper qualification
                        detectPropertyCollision(elemName, ret.properties, element);
                        let dupType = getDefinitionName(elemType, { ns: referencingNS }, namespaces);
                        ret.properties[elemName] = {
                            $ref: '#/definitions/' + dupType
                        };
                        isReference = true;
                    }
                } else {
                    // reference is to another type - recurse
                    addReference(refMap, elemType, {});
                    detectPropertyCollision(elemName, ret.properties, element);
                    ret.properties[elemName] = {
                        $ref: '#/definitions/' + elemType
                    };

                    if (dict.substitutions[elemType]) {
                        var subs = dict.substitutions[elemType];
                        var subLen = subs.length;
                        // add all possible substitutes for this element
                        for (var j = 0; j < subLen; j++) {
                            var sub = subs[j];
                            var subName = sub.name;
                            if (subName == elemName) {
                                // The substituted element is the same name as the
                                // original element.  Therefore we must mangle both property names
                                // and the xml.name field is added to the reference.
                                var propertyName;
                                if (ret.properties[elemName]) {
                                    propertyName = uniquePropertyName(elemType);
                                    ret.properties[propertyName] = u.deepClone(ret.properties[elemName]);
                                    delete ret.properties[elemName];
                                    addReference(refMap, elemType, { xmlName: elemName });
                                    ret.properties[propertyName].$ref = '#/definitions/' +
                                      getDefinitionName(elemType, { xmlName: elemName }, namespaces);
                                    dict.dictEntry[elemType].preventOptimize = true;
                                    var index = propNames.indexOf(elemName);
                                    if (index < 0) {
                                        propNames.splice(index, 1);
                                    }
                                    elemName = propertyName; // The new element name is the mangled property name
                                    propNames.push(propertyName);
                                }
                                propertyName = uniquePropertyName(subs[j].nsName);
                                addReference(refMap, subs[j].nsName, { xmlName: subName });
                                ret.properties[propertyName] = {
                                    $ref: '#/definitions/' + getDefinitionName(subs[j].nsName, { xmlName: subName }, namespaces)
                                };
                                dict.dictEntry[subs[j].nsName].preventOptimize = true;
                                propNames.push(propertyName);
                            } else {
                                // Normal Case: The new substituted element has a different name
                                // than the original element
                                detectPropertyCollision(subName, ret.properties, element);
                                ret.properties[subName] = {
                                    $ref: '#/definitions/' + subs[j].nsName
                                };
                                addReference(refMap, subs[j].nsName, {});
                                propNames.push(subName);
                            }
                        } // end for
                    }
                    isReference = true;
                }
            } else {
                var swaggerType = mapXSDTypeToSwagger(u.stripNamespace(element['undefined'].type));
                detectPropertyCollision(elemName, ret.properties, element);
                ret.properties[elemName] = swaggerType;
                if (!isElemRef) {
                    if (childQualified) {
                        // If within an allOf, then generate the xml object even though this is redundant.
                        // The runtime munges the allOf ref and these properties together and this extra xml is necessary
                        // for the runtime algorithm to work correctly.
                        if (tns && (contextFlags.inAllOf || !ret.xml || tns !== ret.xml.namespace)) {
                            ret.properties[elemName].xml = {
                                namespace: tns,
                                prefix: u.getPrefixForNamespace(tns, namespaces)
                            };
                        }
                    } else {
                        ret.properties[elemName].xml = {
                            namespace: '',
                            prefix: ''
                        };
                    }
                }
            }


            // inner anonymous type
            if ('complexType' in element) {

                if (!element.complexType) {
                    element.complexType = {};
                }

                var complexSchema = {
                    tns: tns,
                    schemaType: 'complex',
                    schema: element.complexType,
                    xmlns: dictEntry.xmlns,
                    qualified: dictEntry.qualified,
                    qualifiedAttr: dictEntry.qualifiedAttr
                };
                var referencingContext = {
                    ns: UNQUALNS
                };
                if (childQualified) {
                    referencingContext.ns = tns;
                }
                var typeRef = generateSwaggerXSO(complexSchema, dict, refMap, namespaces, referencingContext);

                ret.properties[elemName] = typeRef;
                if (ret.properties[elemName]['$ref']) {
                    isReference = true;
                } else if (!ret.properties[elemName].type  && !ret.properties[elemName].allOf) {
                    // If there is no type then this is a special case of a complexType with no content
                    ret.properties[elemName].type = 'object';
                    ret.properties[elemName].properties = {};
                }
            }
            if (element.simpleType) {
                var simpleSchema = {
                    tns: tns,
                    schemaType: 'simple',
                    schema: element.simpleType,
                    xmlns: dictEntry.xmlns,
                    qualified: dictEntry.qualified,
                    qualifiedAttr: dictEntry.qualifiedAttr
                };
                var referencingContextSimple = {
                    ns: UNQUALNS
                };
                if (childQualified) {
                    referencingContextSimple.ns = tns;
                }
                var simpleTypeRef = generateSwaggerXSO(simpleSchema, dict, refMap, namespaces, referencingContextSimple);
                ret.properties[elemName] = simpleTypeRef;
                if (ret.properties[elemName]['$ref']) {
                    isReference = true;
                }
            }

            processElementOccurrence(ret, element, propNames, required, elemNillable, dict, contextFlags);

            // Map default or fixed to the swagger default property
            var item = (ret.properties[elemName].items != null) ? ret.properties[elemName].items : ret.properties[elemName];
            if ('fixed' in element['undefined']) {
                item.default = u.parseToPrimitive(element['undefined'].fixed);
            }
            if ('default' in element['undefined']) {
                item.default = u.parseToPrimitive(element['undefined'].default);
            }

            if (element.annotation) {
                // include annotation as description
                if (element.annotation.documentation) {
                    var doc = u.cleanupDocumentation(element.annotation.documentation);
                    if (isReference && CHILD_DESCRIPTION_PLACED_ON_PARENT) {
                        if (ret.description) {
                            ret.description += ';\n' + elemName + ': ' + doc;
                        } else {
                            ret.description = elemName + ': ' + doc;
                        }
                    } else if (ret.properties[elemName].description) {
                        ret.properties[elemName].description += ';\n' + doc;
                    } else {
                        ret.properties[elemName].description = doc;
                    }
                }
            }
        } // end for
        // now build the required properties list
        if (required.length > 0) {
            if (!ret.required) {
                ret.required = [];
            } else {
                ret.required = u.makeSureItsAnArray(ret.required);
            }
            for (var r = 0; r < required.length; r++) {
                if (ret.required.indexOf(required[r]) < 0) {
                    ret.required = ret.required.concat(required[r]);
                }
            }
        }
    }
}

/**
* Process Occurrence attributes on the element
* @param ret is the portion of the swagger xml being generated
* @param element is the schema elements
* @param propNames is a list of names, the first is the normal property name and the subsequent are substitution group names
* @param elemNillable indicates if the element is elemNillable
* @param dict is the schema dictionary
* @param contextFlags contains contextural flags (for example if we are nested in a group)
**/
function processElementOccurrence(ret, element, propNames, required, elemNillable, dict, contextFlags) {
    // check required existence
    let minElement = getOccurrence(element['undefined'].minOccurs);
    let maxElement = getOccurrence(element['undefined'].maxOccurs);
    let minGroup = getOccurrence(contextFlags.groupMinOccurs);
    let maxGroup = getOccurrence(contextFlags.groupMaxOccurs);

    var fromChoice = element['undefined'].fromChoice;

    // If the property is required add it to the required list
    if (minGroup != 0) {
        if (minElement != 0) {
            if (propNames.length <= 1  && !fromChoice) { // SubstitutionGroup or choice usage indicates property is not required
                if (required.indexOf(propNames[0]) == -1) {
                    required.push(propNames[0]); // minOccurs absent default is 1
                }
            }
        }
    }

    // See if the properties need to be rendered as an array with min and max items
    let maxItems = 1;
    if (maxElement < 0 || maxGroup < 0) {
        maxItems = -1;
    } else if (maxElement >= 0 && maxGroup >= 0) {
        maxItems = maxElement * maxGroup;
    } else {
        maxItems = maxElement;
    }
    let minItems = 1;
    if (minElement == 0 || minGroup == 0) {
        minItems = 0;
    } else if (minElement >= 0 && minGroup >= 0) {
        minItems = minElement * minGroup;
    } else {
        minItems = minElement;
    }

    if (maxItems == -1 || maxItems > 1) {
        // we have an array type - switch out the content
        for (var i = 0; i < propNames.length; i++) {
            let propName = propNames[i];

            var existingContent = ret.properties[propName];
            ret.properties[propName] = {
                type: 'array',
                items: existingContent
            };
            if (maxItems > 1) {
                ret.properties[propName].maxItems = maxItems;
            }
            if (minItems > 0) {
                ret.properties[propName].minItems = minItems;
            }
            if (contextFlags.groupNS && maxGroup != 1) {
                ret.properties[propName]['x-ibm-group'] = u.deepClone(contextFlags.groupNS);
            }

            // For a child A, the namespace information for A is:
            //  i) if a non-array
            //     a) in the definition of the $ref -or
            //     b) in the xml construct -or
            //     c) the namespace in scope if neither (a or b)
            //  ii) if an array
            //     a) in the definition of the items.$ref -or
            //     b) in the items.xml construct -or
            //     c) the namespace in scope if neither (a or b)
            //
            // This can be confusing for an observer of arrays because it
            // seems that the xml should be directly under the A (not within the A.items object).
            // Also there could be hard to find bugs in the map runtime that assume
            // that the xml is directly under the A object.
            // So even though this is redundant, the code duplicates (boosts) the xml
            // information for the "uncommon" case that the items is an inlined object.
            if (ret.properties[propName].items.type &&
                ret.properties[propName].items.type == 'object' &&
                ret.properties[propName].items.xml) {
                ret.properties[propName].xml = u.deepClone(ret.properties[propName].items.xml);
            }
        }
    }

    // add nillable tag if found
    for (var j = 0; j < propNames.length; j++) {
        let propName = propNames[j];
        var rawRefType, lastSlash, refType;
        if (ret.properties && ret.properties[propName]) {
            if (elemNillable) {
                if (ret.properties[propName]['$ref']) {
                    // Even though this is a ref, add the x-nullable tag.
                    // The fixupForNilAndNonNil function in postGenerate
                    // will remove this tag and patch up the ref if necessary.
                    ret.properties[propName]['x-nullable'] = true;
                } else {
                    // plain property - can take extension tag directly
                    ret.properties[propName]['x-nullable'] = true;
                }
            } else if (ret.properties[propName]['$ref']) {
                // made reference to type when not nullable
                // If a definition is referenced in a nillable and not nillable
                // context, this will be detected and cleaned up in fixupForNilAndNonNil.
            }
        }
    }
    return ret;
}

/**
* Detect and issue a message if a property collision
*/
function detectPropertyCollision(key, properties, schema) {
    if (properties[key] || properties[key] === {}) {
        // Indicate that a property collision occured and that the new property overrides the previous one.
        // Currently a message is annotated on the swagger, we could add code to resolve the collision by
        // mangling names.
        // Don't issue the message if we are flattening elements within a choice
        let inChoice = schema && schema['undefined'] && schema['undefined'].fromChoice;
        if (!inChoice) {
            dictionary.annotateWithParserMessage(schema, 'Multiple properties with the name ' + key + ' detected. The property is overwritten with the last definition.');
        }
    }
}

/**
* Return the occurrence count (or -1 if unbounded)
*/
function getOccurrence(occurs) {
    if (occurs === undefined || occurs === null) {
        return 1;
    } else if (typeof occurs === 'number') {
        return occurs;
    } else if (typeof occurs === 'string' && occurs.toLowerCase() == 'unbounded') {
        return -1;
    } else {
        return parseInt(occurs);
    }
}

/**
* Return the xso object for a built-in XSD Type
*/
function mapXSDTypeToSwagger(xsdType) {

    var ret = dictionary.getXSDMapping(xsdType);
    if (!ret) {
        if (xsdType) {
            // Default is to fallback to string
            ret = {
                type: 'string'
            };
        } else {
            // special case for anyType - dont supply a type field at all
            ret = {
                'x-anyType': true,
            };
        }
    }
    return ret;
}

/**
* Determine if the dictionary entry represents a primitive type
*/
function isPrimitiveType(dictEntry, namespaces) {
    let ret = false;
    if (dictEntry && dictEntry.schemaType && dictEntry.schema) {
        if (dictEntry.schemaType == 'simple' && dictEntry.schema.restriction) {
            var restriction = dictEntry.schema.restriction;
            if (restriction['undefined']) {
                if (dictionary.isXSDType(restriction['undefined'].base, namespaces)) {
                    ret = true;
                }
            }
        } else if (dictEntry.schema.simpleContent) {
            var extension = dictEntry.schema.simpleContent.extension;
            if (extension && extension['undefined']) {
                if (dictionary.isXSDType(extension['undefined'].base, namespaces)) {
                    ret = true;
                }
            }
        }
    }
    return ret;
}


// Only merge properties that won't change the core properties of the target
var extensionProperties = {
    enum: true,
    pattern: true,
    format: true,
    default: true,
    minimum: true,
    maximum: true,
    exclusiveMinimum: true,
    exclusiveMaximum: true,
    minLength: true,
    maxLength: true,
    'x-ibm-whiteSpace': true,
    'x-ibm-fractionDigits': true,
    'x-ibm-totalDigits': true,
    description: true
};

/**
* @param source is an XSO object
* @param target is an XSO object that needs to new information from the source
*
* Only certain properties (decorations) are copied over.
*/
function extendXSO(target, source) {
    for (var name in source) {
        if (extensionProperties[name]) {
            target[name] = source[name];
        }
    }
    return target;
}

/**
* Generate a unique property name in the cases where we have a collision (ie. subgroups)
*/
function uniquePropertyName(ref) {
    var words = ref.split('_');
    return words[1] + ':' + words[0];
}

/**
 * Return new references for subtypes whose base is
 * in swagger
 */
function getExtraReferencesForSubTypes(subTypes, swagger) {
    var refMap = {};
    for (var baseType in subTypes) {
        if (swagger.definitions[baseType]) {
            var subTypeList = subTypes[baseType];

            for (var i = 0; i < subTypeList.length; i++) {
                var subType = subTypeList[i];
                if (!swagger.definitions[subType]) {
                    addReference(refMap, subType, {});
                }
            }
        }
    }
    return refMap;
}

exports.addReference = addReference;
exports.extendXSO = extendXSO;
exports.generateSwaggerDefinitions = generateSwaggerDefinitions;
exports.generateSwaggerXSO = generateSwaggerXSO;
exports.getExtraReferencesForSubTypes = getExtraReferencesForSubTypes;
exports.mapXSDTypeToSwagger = mapXSDTypeToSwagger;
exports.UNQUALNS = UNQUALNS;
