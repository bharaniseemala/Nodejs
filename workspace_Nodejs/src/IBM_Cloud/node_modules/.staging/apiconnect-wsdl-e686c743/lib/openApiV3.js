/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Utilities to update from Open API V2 to V3
**/

const u = require('../lib/utils.js');
var q = require('q');
const util = require('util');

// The swagger2openapi is the defacto conversion package
var swagger2openapi = null;
try {
    swagger2openapi = require('swagger2openapi');
} catch (e) {
    swagger2openapi = null;
}

/**
* Conversion is only available if the converter code is included
*/
function isOpenApiV3Available() {
    return swagger2openapi != null;
}

/**
* Converts the swagger (and embedded swaggers to Open API V3)
* @returns a promise containing the Open API V3 of the swagger
*/
function getOpenApiV3(swagger) {
    let def = q.defer();

    // Assume that if root swagger is V3 then the embedded ones are too.
    if (swagger.openapi >= 3) {
        def.resolve(swagger);
        return def.promise;
    }

    if (!isOpenApiV3Available()) {
        def.reject(new Error('Open API V3 Conversion is unavailable.'));
        return def.promise;
    }

    let options = { patch: true };
    swagger2openapi.convertObj(swagger, options). then(function(options) {
        try {
            let swagger = options.openapi;
            if (swagger['x-ibm-configuration'].targets) {
                // Convert all of the inner swaggers
                let promises = [];
                let title2key = {};
                for (let key in swagger['x-ibm-configuration'].targets) {
                    let inner = u.deepClone(swagger['x-ibm-configuration'].targets[key]);
                    // Replace the nested references with root references prior to the conversion
                    replaceRefs(inner,
                      [ { source: '#/x-ibm-configuration/targets/' + key + '/',
                          target: '#/' } ]);
                    title2key[inner.info.title] = key;
                    promises.push(swagger2openapi.convertObj(inner, options));
                }
                Promise.all(promises).then(values => {
                    for (let i = 0; i < values.length; i++) {
                        let key = title2key[values[i].openapi.info.title];
                        // Replace the root references with nested references
                        replaceRefs(values[i].openapi,
                          [ { source: '#/',
                              target: '#/x-ibm-configuration/targets/' + key + '/' } ]);
                        swagger['x-ibm-configuration'].targets[key] = values[i].openapi;
                    }
                    // Finally replace any remaining references (in the assembly) with the new references
                    replaceRefs(swagger,
                      [ { source: '/definitions/',
                          target: '/components/schemas/' } ]);
                    def.resolve(swagger);
                }).catch(reason => {
                    def.reject(reason);
                });
            } else {
                def.resolve(swagger);
            }
        } catch (e) {
            def.reject(e);
        }
    }, function(e) {
        def.reject(e);
    });
    return def.promise;
}

/**
* String replacement on each ref
*/
function replaceRefs(obj, list) {
    if (Array.isArray(obj)) {
        let len = obj.length;
        for (var j = 0; j < len; j++) {
            // recurse array element
            replaceRefs(obj[j], list);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == '$ref') {
                    var ref = obj[key];
                    for (let i = 0; i < list.length; i++) {
                        if (ref.indexOf(list[i].source >= 0)) {
                            obj[key] = ref.replace(list[i].source, list[i].target);
                            break;
                        }
                    }
                    return;
                } else {
                    // recurse
                    replaceRefs(obj[key], list);
                }
            }
        }
    }
}

/**
* Validate the swagger and embedded swagger with the swagger2openapi validator
*/
function validate(swagger) {
    if (!isOpenApiV3Available()) {
        let def = q.defer();
        def.reject(new Error('Open API V3 Conversion is unavailable.'));
        return def.promise;
    }

    swagger = u.deepClone(swagger);
    changeNamespaces(swagger);

    // Validate the whole swagger, then validate any embedded swaggers.
    let promises = [];
    promises.push(_validate(swagger));
    for (let target in swagger['x-ibm-configuration'].targets) {
        promises.push(_validate(swagger['x-ibm-configuration'].targets[target], target));
    }
    return Promise.all(promises);
}

/**
* Validate the swagger.  If this is an embedded swagger, then target is the name
* of the target.
*/
function _validate(swagger, target) {
    if (target) {
        // If an embedded swagger, then change the refrences to look like root references.
        swagger = u.deepClone(swagger);
        replaceRefs(swagger,
          [ { source: '#/x-ibm-configuration/targets/' + target + '/',
              target: '#/' } ]);
    }
    let def = q.defer();
    let errorText = '';
    let validator = require('swagger2openapi/validate.js');
    validator.validate(swagger, { laxurls: true, warnOnly: true }, function(err, options) {
        if (err) {
            // Ignore this dumb error.
            if (err.message.indexOf('to be a number') < 0) {
                errorText = err + '\n';
            }
        }
        if (options && options.warnings) {
            for (let i = 0; i < options.warnings.length; i++) {
                errorText += 'Warning:' + options.warnings[i] + '\n';
            }
        }
        if (errorText.length > 0) {
            def.reject(new Error(errorText));
        } else {
            def.resolve();
        }
    });
    return def.promise;
}

/**
* Utility to remove Empty Namespaces
*/
function changeNamespaces(obj) {
    if (Array.isArray(obj)) {
        for (var j = 0; j < obj.length; j++) {
            // recurse array element
            changeNamespaces(obj[j]);
        }
    } else if (obj && typeof obj === 'object') {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (key == 'namespace') {
                    if (obj.prefix && obj.prefix.length > 0) {
                        // Provide a valid fake url
                        obj.namespace = 'http://temp.com/' + obj.prefix;
                    } else {
                        // Remove the namespace to avoid issues
                        delete obj[key];
                    }
                    return;
                } else {
                    // recurse
                    changeNamespaces(obj[key]);
                }
            }
        }
    }
}

exports.getOpenApiV3 = getOpenApiV3;
exports.isOpenApiV3Available = isOpenApiV3Available;
exports.validate = validate;
