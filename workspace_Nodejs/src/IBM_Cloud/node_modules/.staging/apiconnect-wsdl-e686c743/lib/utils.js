/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

// NCName Reserved for global messages
var RESERVED_DEF = 'APIC__RESERVED';

/**
* Utility functions for the apiconnect-wsdl parser
**/

/**
* Return an array representation of the object
*/
function makeSureItsAnArray(obj, addNilObjects) {
    var ret = obj;
    if (!Array.isArray(obj)) {
        ret = [];
        if (obj || addNilObjects) {
            ret.push(obj);
        }
    }
    return ret;
}

/**
* Strip the prefix and return just the xsd name (aka xsd ncName)
*/
function stripNamespace(name) {
    var localName = name;
    if (name) {
        var index = name.indexOf(':');
        if (index != -1) {
            localName = name.substr(index + 1);
        }
    }
    return localName;
}

function slugifyName(title) {
    var name = title;
    if (name) {
    // multiple spaces replaced by single hyphen
        name = name.replace(/ +/gi, '-');
        // multiple hyphens replaced by single hyphen
        name = name.replace(/-+/gi, '-');
        // anything not a-z 0-9 A-Z hyphen removed
        name = name.replace(/[^A-Za-z0-9\\-]/gi, '');
        // remove all start hyphens
        name = name.replace(/^[-]+/, '');
        // remove all end hyphens
        name = name.replace(/[-]+$/, '');
        // remove all start numbers
        name = name.replace(/^[0-9]+/, '');
        // only lower case
        name = name.toLowerCase();
    }
    return name;
}

function randomAlphaString(length) {
    var chars = 'abcdefghijklmnopqrstuvwxyz';
    var charLen = chars.length;
    var ret = '';
    for (var i = 0; i < length; i++) {
        ret += chars[Math.floor(Math.random() * charLen)];
    } // end for
    return ret;
}

/**
* @return a deep clone of obj
*/
function deepClone(obj) {
    if (obj === null) {
        return null;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    var child, cloned;
    if (obj instanceof Array) {
        child = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            cloned = deepClone(obj[i]);
            child.push(cloned);
        } // end for
    } else {
        child = {};
        for (var key in obj) {
            cloned = deepClone(obj[key]);
            child[key] = cloned;
        } // end for
    }
    return child;
}

/**
* @parm obj
* @param ignore keys to ignore
* @return a deep clone of obj
*/
function deepCloneWithIgnoreKeys(obj, ignore) {
    if (obj === null) {
        return null;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    var child, cloned;
    if (obj instanceof Array) {
        child = [];
        var len = obj.length;
        for (var i = 0; i < len; i++) {
            cloned = deepCloneWithIgnoreKeys(obj[i], ignore);
            child.push(cloned);
        } // end for
    } else {
        child = {};
        for (var key in obj) {
            if (ignore.indexOf(key) < 0) {
                cloned = deepCloneWithIgnoreKeys(obj[key], ignore);
                child[key] = cloned;
            }
        } // end for
    }
    return child;
}

/**
* Add objects within source to target
*/
function extendObject(target, source, deep) {
    for (var name in source) {
        if (deep) {
            target[name] = deepClone(source[name]);
        } else {
            target[name] = source[name];
        }
    } // end for
    return target;
}

function getObjectName(o) {
    return o && o.constructor && o.constructor.name;
}

/**
* Get a prefix for the indicated namespace, create a new prefix if not typesFound
*/
function getPrefixForNamespace(ns, namespaces) {
    var ret = '';
    var tempPrefix = '';
    if (!ns || ns === '') {
        return '';
    }
    if (ns && namespaces != null && typeof namespaces === 'object') {
        for (var prefix in namespaces) {
            var namespace = namespaces[prefix];
            if (ns == namespace) {
                if (prefix.substr(0, 1) == '_') {
                    // try not to use underscored prefixes if we can avoid it
                    tempPrefix = prefix;
                } else {
                    ret = prefix;
                    break;
                }
            }
        } // end for
        if (!ret && tempPrefix) {
            ret = tempPrefix;
        }
        if (!ret && ns) {
            // didn't find a match - need to add a new auto generated one
            var index = 1;
            var newPrefix = 'ns' + index;
            while (namespaces[newPrefix]) {
                index += 1;
                newPrefix = 'ns' + index;
            } // end while
            namespaces[newPrefix] = ns;
            ret = newPrefix;
        }
    }
    return ret;
}

/**
* Return a string representation of the value.
*/
function parseToPrimitive(value) {
    try {
        return JSON.parse(value);
    } catch (e) {
        return value.toString();
    }
}

// list the keys not shared by two objects or those amended since last processed
function disjointKeysToArray(obj, notInObj) {
    var ret = [];
    for (var key in obj) {
        if (!notInObj[key]) {
            ret.push({
                name: key,
                value: obj[key]
            });
        } else {
            var previous = notInObj[key];
            if (previous && previous.offset != previous.referencingContexts.length) {
                ret.push({
                    name: key,
                    value: obj[key]
                });
            }
        }
    } // end for
    return ret;
}


/**
* @param documentation is a node.soap documentation object
* The documentation element may have 'undefined' or '$value' keys.
* These are removed or changed so that the documentation object is
* either a string or an array of strings.
* @return a string representing the entire text of the documentation.
* The returned string is often used to set a description field in the
* swagger document.
*/
function cleanupDocumentation(documentation) {
    var ret = documentation;
    if (documentation) {
        if (typeof documentation === 'string') {
            ret = documentation;
        } else {
            // Convert to array and remove attributes from the documentation element
            documentation = makeSureItsAnArray(documentation);
            for (var i = 0; i < documentation.length; i++) {
                if (documentation[i]) {
                    if (documentation[i]['undefined']) {
                        delete documentation[i]['undefined'];
                    }
                    if (documentation[i]['$value']) {
                        documentation[i] = documentation[i]['$value'];
                    }
                }
            }
            // Return the single document or a string representation of all the documents
            if (documentation.length == 1 && documentation[0] && typeof documentation[0] === 'string') {
                ret = documentation[0];
            } else {
                ret = JSON.stringify(documentation);
            }
        }
    }
    return ret;
}

/**
* return the apiconnect-wsdl getVersion
*/
function getVersion() {
    return require('./../package.json').version;
}

// Don't trigger asserts in production code.
var useAsserts = false;
function setAsserts(val) {
    useAsserts = val;
}

function makeValidationErr(message) {
    let valError = new Error(message);
    return convertToValidationErr(valError);
}
/**
* Add text message to the error using the validator format
* { messages: [ {message: <message>}]}
* @param valError the validator style error
* @param stringOrErr the new error to add to valError
*/
function addValidationErr(valError, stringOrErr) {
    // Add the messages array
    if (!valError.messages) {
        valError.messages = [];
    }
    // Get the new message
    let message = 'no message';
    try {
        if (typeof stringOrErr === 'string') {
            message = stringOrErr;
        } else {
            if (stringOrErr.message) {
                message = stringOrErr.message;
            } else {
                message = JSON.stringify(stringOrErr);
            }
        }
        message = message.replace('Error occurred while parsing "MEMORY"\n', '');
    } catch (e) {
        message = 'no message';
    }
    // Add the new message to the messages array
    valError.messages.push({
        message: message
    });
    // Update the error message to be the combined text of all messages.
    valError.message = '';
    let nl = '';
    for (let i = 0; i < valError.messages.length; i++) {
        valError.message += nl + valError.messages[i].message;
        nl = '\n';
    }
    return valError;
}

function convertToValidationErr(err) {
    if (!err.messages || !(err.messages instanceof Array)) {
        err.messages = [ { message: err.message } ];
    }
    return err;
}

/**
* Load and store from yaml as a quick validation and fixup for any encoding issues.
**/
function checkAndFix(object) {
    try {
        return require('js-yaml').safeLoad(require('js-yaml').safeDump(object,
           { skipInvalid: true } // Suppress dumping of keys with undefined values without error
        ));
    } catch (e) {
        throw e;
    }
}

exports.addValidationErr = addValidationErr;
exports.cleanupDocumentation = cleanupDocumentation;
exports.convertToValidationErr = convertToValidationErr;
exports.deepClone = deepClone;
exports.deepCloneWithIgnoreKeys = deepCloneWithIgnoreKeys;
exports.disjointKeysToArray = disjointKeysToArray;
exports.extendObject = extendObject;
exports.checkAndFix = checkAndFix;
exports.getObjectName = getObjectName;
exports.getVersion = getVersion;
exports.getPrefixForNamespace = getPrefixForNamespace;
exports.makeSureItsAnArray = makeSureItsAnArray;
exports.makeValidationErr = makeValidationErr;
exports.parseToPrimitive = parseToPrimitive;
exports.randomAlphaString = randomAlphaString;
exports.setAsserts = setAsserts;
exports.slugifyName = slugifyName;
exports.stripNamespace = stripNamespace;
exports.useAsserts = useAsserts;
exports.RESERVED_DEF = RESERVED_DEF;
