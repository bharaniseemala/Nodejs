/** ******************************************************* {COPYRIGHT-TOP} ***
 * Licensed Materials - Property of IBM
 * 5725-Z22, 5725-Z63, 5725-U33, 5725-Z63
 *
 * (C) Copyright IBM Corporation 2016, 2018
 *
 * All Rights Reserved.
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 ********************************************************** {COPYRIGHT-END} **/

'use strict';

/**
* Update functions for the apiconnect-wsdl parser
**/

var u = require('../lib/utils.js');
var wsdl = require('../src/wsdl.js');
var openApiV3 = require('../lib/openApiV3.js');

const jsyaml = require('js-yaml');
var fs = require('fs');
var q = require('q');


/**
* Return promise with new swagger that is the originalSwagger
* ammended with new service swaggers sourced from allWSDLs
*/
function updateOpenApiFromWSDL(originalSwagger, allWSDLs, wsdlId) {
    let def = q.defer();

    if ((typeof originalSwagger) === 'string') {
        originalSwagger = jsyaml.safeLoad(fs.readFileSync(originalSwagger, 'utf8'));
    }

    let swaggers = getSwaggers(originalSwagger, allWSDLs, wsdlId);

    if (originalSwagger.openapi >= 3) {
        // Convert each swagger to version 3
        let promises = [];
        for (let i = 0; i < swaggers.length; i++) {
            promises.push(openApiV3.getOpenApiV3(swaggers[i]));
        }
        Promise.all(promises).then(values => {
            try {
                // Combine the files into one array
                swaggers = [];
                for (let i = 0; i < values.length; i++) {
                    swaggers.push(values[i]);
                }
                let swagger = originalSwagger;
                for (let j = 0; j < swaggers.length; j++) {
                    swagger = updateSwagger(swagger, swaggers[j], wsdlId);
                }
                def.resolve(swagger);
            } catch (e) {
                def.reject(e);
            }
        }).catch(reason => {
            def.reject(reason);
        });
    } else {
        try {
            let swagger = originalSwagger;
            for (let j = 0; j < swaggers.length; j++) {
                swagger = updateSwagger(swagger, swaggers[j], wsdlId);
            }
            def.resolve(swagger);
        } catch (e) {
            def.reject(e);
        }
    }
    return def.promise;
}

/**
* Return new swagger that is the originalSwagger
* ammended with new service swaggers sourced from allWSDLs
*/
function updateSwaggerFromWSDL(originalSwagger, allWSDLs, wsdlId) {
    if ((typeof originalSwagger) === 'string') {
        originalSwagger = jsyaml.safeLoad(fs.readFileSync(originalSwagger, 'utf8'));
    }

    let swaggers = getSwaggers(originalSwagger, allWSDLs, wsdlId);

    // Update the original swagger
    var swagger = originalSwagger;
    for (var j = 0; j < swaggers.length; j++) {
        swagger = updateSwagger(swagger, swaggers[j], wsdlId);
    }
    return swagger;
}

/**
* @return a list of swaggers for each service in allWSDLs
*/
function getSwaggers(originalSwagger, allWSDLs, wsdlId) {
    // Get wsdl service names from the original swagger
    var publicService = null;
    var services = [];
    if (originalSwagger['x-ibm-configuration'] &&
        originalSwagger['x-ibm-configuration']['wsdl-definition'] &&
        originalSwagger['x-ibm-configuration']['wsdl-definition'].service) {
        publicService = originalSwagger['x-ibm-configuration']['wsdl-definition'].service;
        services.push(publicService);
    }

    if (originalSwagger['x-ibm-configuration'] &&
        originalSwagger['x-ibm-configuration'].targets) {
        for (var t in originalSwagger['x-ibm-configuration'].targets) {
            var target = originalSwagger['x-ibm-configuration'].targets[t];
            if (target['x-ibm-configuration'] &&
                target['x-ibm-configuration']['wsdl-definition'] &&
                target['x-ibm-configuration']['wsdl-definition'].service) {
                var s = target['x-ibm-configuration']['wsdl-definition'].service;
                if (services.indexOf(s) < 0) {
                    services.push(s);
                }
            }
        }
    }

    // Get all of the services
    var serviceData = wsdl.getWSDLServices(allWSDLs);
    var swaggers = [];
    // Create swaggers for matching services
    if (serviceData && serviceData.services) {
        for (var i = 0; i < serviceData.services.length; i++) {
            var sd = serviceData.services[i];
            if (services.indexOf(sd.service) >= 0) {
                var wsdlEntry = wsdl.findWSDLForServiceName(allWSDLs, sd.service);
                swaggers.push(wsdl.getSwaggerForService(wsdlEntry, sd.service, wsdlId));
            }
        }
    }

    // If no swaggers found, throw an error
    if (swaggers.length === 0) {
        throw new Error('The wsdl contains the following service(s) ' + services +
         '. The api does not reference any of these services.' +
         ' Provide a new wsdl file or change the api\'s wsdl-definition.service field.');
    }

    // Update the original swagger
    var swagger = originalSwagger;
    for (var j = 0; j < swaggers.length; j++) {
        swagger = updateSwagger(swagger, swaggers[j], wsdlId);
    }
    return swaggers;
}

/**
*  Similar to UpdateSwagger, but also converts to openAPI V3
*  @returns promise containing the updated swagger
*/
function updateOpenApi(swagger1, swagger2, wsdlId, verbose) {
    let version1 = swagger1.swagger || swagger1.openapi;
    let version2 = swagger1.swagger || swagger1.openapi;
    let def = q.defer;
    if (version1 == version2) {
        try {
            let swagger = updateSwagger(swagger1, swagger2, wsdlId, verbose);
            def.resolve(swagger);
        } catch (e) {
            def.reject(e);
        }
    } else {
        if (version1 >= 3) {
            openApiV3.getOpenApiV3(swagger2).then(function(swagger2) {
                try {
                    let swagger = updateSwagger(swagger1, swagger2, wsdlId, verbose);
                    def.resolve(swagger);
                } catch (e) {
                    def.reject(e);
                }
            }, function(e) {
                def.reject(e);
            });
        }
    }
    return def.promise;
}

/**
 * Return new swagger that is the original swagger (swagger1)
 * ammended with api information from a new swagger (swagger2)
 * @return updated swagger
 */
function updateSwagger(swagger1, swagger2, wsdlId, verbose) {

    let version1 = swagger1.swagger || swagger1.openapi;
    let version2 = swagger1.swagger || swagger1.openapi;
    if (version1 != version2) {
        throw new Error('different versions of open api detected: ' + version1 + ' and ' + version2);
    }

    if ((typeof swagger1) === 'string') {
        swagger1 = jsyaml.safeLoad(fs.readFileSync(swagger1, 'utf8'));
    }
    if ((typeof swagger2) === 'string') {
        swagger2 = jsyaml.safeLoad(fs.readFileSync(swagger2, 'utf8'));
    }

    // Create swagger3 (result swagger) from the original swagger.
    // We want to keep most of the information.
    var swagger3 = u.deepClone(swagger1);

    // Update the root api (paths)
    // Find the service (if specified) for the orignal swagger
    var service = null;
    if (swagger1['x-ibm-configuration'] && swagger1['x-ibm-configuration']['wsdl-definition']) {
        service = swagger1['x-ibm-configuration']['wsdl-definition'].service;
        if (verbose) {
            console.log('Original yaml: Found public wsdl service: ' + service);
        }
    } else if (verbose) {
        console.log('Original yaml: No public wsdl service');
    }

    if (!service) {
        // No service found, update root information with new yaml if new yaml does not have a service either
        if (!swagger2['x-ibm-configuration'] ||
            !swagger2['x-ibm-configuration']['wsdl-definition']) {
            if (verbose) {
                console.log('New yaml: No public wsdl service');
                console.log('UPDATE: new yaml [public] -> updated yaml [public]');
            }
            updateSection(swagger1, null, swagger2, null, swagger3);
        } else {
            // No changes
        }
    } else if (swagger2['x-ibm-configuration'] &&
               swagger2['x-ibm-configuration']['wsdl-definition'] &&
               swagger2['x-ibm-configuration']['wsdl-definition'].service == service) {
        if (verbose) {
            console.log('New yaml: Found public wsdl service: ' + service);
            console.log('UPDATE: new yaml [public] -> updated yaml [public]');
        }
        updateSection(swagger1, null, swagger2, null, swagger3);

        // If wsdlId is set, then also update the public wsdl to the wsdlId
        if (wsdlId) {
            swagger3['x-ibm-configuration']['wsdl-definition'].wsdl = wsdlId;
        }

    } else if (swagger2['x-ibm-configuration'].targets) {
        for (var targetName in swagger2['x-ibm-configuration'].targets) {
            if (swagger2['x-ibm-configuration'].targets[targetName]['wsdl-definition'] &&
                swagger2['x-ibm-configuration'].targets[targetName]['wsdl-definition'].service == service) {
                if (verbose) {
                    console.log('New yaml: Found implentation wsdl service: ' + service + ' in target ' + targetName);
                    console.log('UPDATE: new yaml [' + targetName + '] -> updated yaml [public]');
                }
                updateSection(swagger1, null, swagger2, targetName, swagger3);
            }
        }
    }

    // Now update any embedded implementation target services
    if (swagger1['x-ibm-configuration'].targets) {
    // For each implementation service in the original, find and update with a matching service from the new yaml
        for (var targetName1 in swagger1['x-ibm-configuration'].targets) {
            service = null;
            var target1 = swagger1['x-ibm-configuration'].targets[targetName1];
            if (target1['x-ibm-configuration'] && target1['x-ibm-configuration']['wsdl-definition']) {
                service = target1['x-ibm-configuration']['wsdl-definition'].service;
                if (verbose) {
                    console.log('Original yaml: Found implementation service in original yaml: ' + service + ' within target ' + targetName1);
                }
            }
            if (service) {
                if (swagger2['x-ibm-configuration'] &&
                    swagger2['x-ibm-configuration']['wsdl-definition'] &&
                    swagger2['x-ibm-configuration']['wsdl-definition'].service == service) {
                    if (verbose) {
                        console.log('New yaml: Found public wsdl service: ' + service);
                        console.log('UPDATE: new yaml [public] -> updated yaml [' + targetName1 + ']');
                    }
                    updateSection(swagger1, targetName1, swagger2, null, swagger3);
                } else if (swagger2['x-ibm-configuration'].targets) {
                    for (var targetName2 in swagger2['x-ibm-configuration'].targets) {
                        if (swagger2['x-ibm-configuration'].targets[targetName2]['wsdl-definition'] &&
                            swagger2['x-ibm-configuration'].targets[targetName2]['wsdl-definition'].service == service) {
                            if (verbose) {
                                console.log('New yaml: Found implementation service in original yaml: ' + service + ' within target ' + targetName2);
                                console.log('UPDATE: new yaml [' + targetName2 + '] -> updated yaml [' + targetName1 + ']');
                            }
                            updateSection(swagger1, targetName1, swagger2, targetName2, swagger3);
                        }
                    }
                }
            }
        }
    }

    return swagger3;
}

/**
 * Return new swagger that is the original swagger (swagger1)
 * ammended with a new swagger (swagger2) from a wsdl or upload
 */
function updateSection(swagger1, section1, swagger2, section2, swagger3) {

    var implementationService = false;
    if (section1) {
        swagger1 = swagger1['x-ibm-configuration'].targets[section1];
        swagger3 = swagger3['x-ibm-configuration'].targets[section1];
    }

    if (section2) {
        swagger2 = swagger2['x-ibm-configuration'].targets[section2];
    }

    // Update parser version
    if (swagger3['x-ibm-configuration'] &&
        swagger3['x-ibm-configuration']['wsdl-definition'] &&
        swagger2['x-ibm-configuration'] &&
        swagger2['x-ibm-configuration']['wsdl-definition'] &&
        swagger2['x-ibm-configuration']['wsdl-definition']['parser-version']) {
        swagger3['x-ibm-configuration']['wsdl-definition']['parser-version'] =
          swagger2['x-ibm-configuration']['wsdl-definition']['parser-version'];
    }

    // Analyze paths
    for (var pathName in swagger1.paths) {
        if (!swagger2.paths[pathName]) {
            delete swagger3.paths[pathName]; // Delete paths not in the new swagger
        } else {
            updatePath(swagger3.paths[pathName], swagger2.paths[pathName]);
            swagger3.paths[pathName] = updateRefs(swagger3.paths[pathName], section1, section2);
        }
    }

    // Copy new paths to swagger3
    for (pathName in swagger2.paths) {
        if (!swagger3.paths[pathName]) {
            swagger3.paths[pathName] = u.deepClone(swagger2.paths[pathName]);
            swagger3.paths[pathName] = updateRefs(swagger3.paths[pathName], section1, section2);
        }
    }

    // Get the definitions or components/schemas object
    let s1 = definitionsOrSchemas(swagger1);
    let s2 = definitionsOrSchemas(swagger2);
    let s3 = definitionsOrSchemas(swagger3);
    for (var defName in s1) {
        if (!s2[defName]) {
            delete s3[defName]; // Delete definitions not in the new wsdl...we don't know if the user added these or not
        } else {
            s3[defName] = u.deepClone(s2[defName]);
            s3[defName] = updateRefs(s3[defName], section1, section2);
        }
    }

    for (defName in s2) {
        if (!s3[defName]) {
            s3[defName] = u.deepClone(s2[defName]);
            s3[defName] = updateRefs(s3[defName], section1, section2);
        }
    }
    // Delete implementation examples from swagger3...They really are not needed.
    if (implementationService) {
        for (defName in s3) {
            if (s3[defName].example) {
                s3[defName].example = ''; // Replace with empty string
            }
        }
    }

    // Respect Security setting in Headers
    for (defName in s3) {
        if (defName.endsWith('Header') && s1[defName]) {
            if (!s1[defName].properties ||
                !s1[defName].properties.Security) {
                if (s3[defName].properties &&
                    s3[defName].properties.Security) {
                    delete s3[defName].properties.Security;
                }
            }
        }
    }
    return swagger3;
}

function updatePath(path3, path2) {
    for (var methodName in path3) {
        if (!path2[methodName]) {
            delete path3[methodName]; // Delete methods not in the new wsdl
        }
    }

    for (methodName in path2) {
        if (path3[methodName]) {
            // Replace the method with the new one.
            // Preserve the operationId and summary because these are auto-gen'd and updated by customer in many cases
            var operationId = path3[methodName].operationId;
            var summary = path3[methodName].summary;
            path3[methodName] = u.deepClone(path2[methodName]);
            path3[methodName].operationId = operationId;
            path3[methodName].summary = summary;
            // what about headers and non-soap parameters ?
        } else {
            path3[methodName] = u.deepClone(path2[methodName]);
        }
    }
    return;
}

function updateRefs(json, section1, section2) {
    if (section1 == section2) {
        return json;
    }

    let jsonString = JSON.stringify(json);
    let source1 = section2 ? '#/x-ibm-configuration/targets/' + section2 + '/definitions/' : '#/definitions/';
    let target1 = section1 ? '#/x-ibm-configuration/targets/' + section1 + '/definitions/' : '#/definitions/';
    let source2 = section2 ? '#/x-ibm-configuration/targets/' + section2 + '/components/schemas/' : '#/components/schemas/';
    let target2 = section1 ? '#/x-ibm-configuration/targets/' + section1 + '/components/schemas/' : '#/components/schemas/';


    jsonString = jsonString.replace(new RegExp(source1, 'g'), target1);
    jsonString = jsonString.replace(new RegExp(source2, 'g'), target2);
    return JSON.parse(jsonString);
}

/**
* @returns defintions (V2) or components.schemas (V3)
*/
function definitionsOrSchemas(swagger) {
    if (swagger.openapi) {
        return swagger.components ? swagger.components.schemas : null;
    }
    return swagger.definitions;
}

exports.updateSwaggerFromWSDL = updateSwaggerFromWSDL;
exports.updateSwagger = updateSwagger;
exports.updateOpenApiFromWSDL = updateOpenApiFromWSDL;
exports.updateOpenApi = updateOpenApi;
